{"/home/travis/build/npmtest/node-npmtest-validate.js/test.js":"/* istanbul instrument in package npmtest_validate_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-validate.js/lib.npmtest_validate.js.js":"/* istanbul instrument in package npmtest_validate_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_validate_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_validate_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-validate.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-validate.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_validate_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_validate_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_validate_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_validate_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_validate_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_validate_js.__dirname + '/lib.npmtest_validate_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/validate.js":"/*!\n * validate.js 0.11.1\n *\n * (c) 2013-2016 Nicklas Ansman, 2013 Wrapp\n * Validate.js may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://validatejs.org/\n */\n\n(function(exports, module, define) {\n  \"use strict\";\n\n  // The main function that calls the validators specified by the constraints.\n  // The options are the following:\n  //   - format (string) - An option that controls how the returned value is formatted\n  //     * flat - Returns a flat array of just the error messages\n  //     * grouped - Returns the messages grouped by attribute (default)\n  //     * detailed - Returns an array of the raw validation data\n  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.\n  //\n  // Please note that the options are also passed to each validator.\n  var validate = function(attributes, constraints, options) {\n    options = v.extend({}, v.options, options);\n\n    var results = v.runValidations(attributes, constraints, options)\n      , attr\n      , validator;\n\n    for (attr in results) {\n      for (validator in results[attr]) {\n        if (v.isPromise(results[attr][validator])) {\n          throw new Error(\"Use validate.async if you want support for promises\");\n        }\n      }\n    }\n    return validate.processValidationResults(results, options);\n  };\n\n  var v = validate;\n\n  // Copies over attributes from one or more sources to a single destination.\n  // Very much similar to underscore's extend.\n  // The first argument is the target object and the remaining arguments will be\n  // used as sources.\n  v.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(source) {\n      for (var attr in source) {\n        obj[attr] = source[attr];\n      }\n    });\n    return obj;\n  };\n\n  v.extend(validate, {\n    // This is the version of the library as a semver.\n    // The toString function will allow it to be coerced into a string\n    version: {\n      major: 0,\n      minor: 11,\n      patch: 1,\n      metadata: null,\n      toString: function() {\n        var version = v.format(\"%{major}.%{minor}.%{patch}\", v.version);\n        if (!v.isEmpty(v.version.metadata)) {\n          version += \"+\" + v.version.metadata;\n        }\n        return version;\n      }\n    },\n\n    // Below is the dependencies that are used in validate.js\n\n    // The constructor of the Promise implementation.\n    // If you are using Q.js, RSVP or any other A+ compatible implementation\n    // override this attribute to be the constructor of that promise.\n    // Since jQuery promises aren't A+ compatible they won't work.\n    Promise: typeof Promise !== \"undefined\" ? Promise : /* istanbul ignore next */ null,\n\n    EMPTY_STRING_REGEXP: /^\\s*$/,\n\n    // Runs the validators specified by the constraints object.\n    // Will return an array of the format:\n    //     [{attribute: \"<attribute name>\", error: \"<validation result>\"}, ...]\n    runValidations: function(attributes, constraints, options) {\n      var results = []\n        , attr\n        , validatorName\n        , value\n        , validators\n        , validator\n        , validatorOptions\n        , error;\n\n      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {\n        attributes = v.collectFormValues(attributes);\n      }\n\n      // Loops through each constraints, finds the correct validator and run it.\n      for (attr in constraints) {\n        value = v.getDeepObjectValue(attributes, attr);\n        // This allows the constraints for an attribute to be a function.\n        // The function will be called with the value, attribute name, the complete dict of\n        // attributes as well as the options and constraints passed in.\n        // This is useful when you want to have different\n        // validations depending on the attribute value.\n        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);\n\n        for (validatorName in validators) {\n          validator = v.validators[validatorName];\n\n          if (!validator) {\n            error = v.format(\"Unknown validator %{name}\", {name: validatorName});\n            throw new Error(error);\n          }\n\n          validatorOptions = validators[validatorName];\n          // This allows the options to be a function. The function will be\n          // called with the value, attribute name, the complete dict of\n          // attributes as well as the options and constraints passed in.\n          // This is useful when you want to have different\n          // validations depending on the attribute value.\n          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);\n          if (!validatorOptions) {\n            continue;\n          }\n          results.push({\n            attribute: attr,\n            value: value,\n            validator: validatorName,\n            globalOptions: options,\n            attributes: attributes,\n            options: validatorOptions,\n            error: validator.call(validator,\n                value,\n                validatorOptions,\n                attr,\n                attributes,\n                options)\n          });\n        }\n      }\n\n      return results;\n    },\n\n    // Takes the output from runValidations and converts it to the correct\n    // output format.\n    processValidationResults: function(errors, options) {\n      errors = v.pruneEmptyErrors(errors, options);\n      errors = v.expandMultipleErrors(errors, options);\n      errors = v.convertErrorMessages(errors, options);\n\n      var format = options.format || \"grouped\";\n\n      if (typeof v.formatters[format] === 'function') {\n        errors = v.formatters[format](errors);\n      } else {\n        throw new Error(v.format(\"Unknown format %{format}\", options));\n      }\n\n      return v.isEmpty(errors) ? undefined : errors;\n    },\n\n    // Runs the validations with support for promises.\n    // This function will return a promise that is settled when all the\n    // validation promises have been completed.\n    // It can be called even if no validations returned a promise.\n    async: function(attributes, constraints, options) {\n      options = v.extend({}, v.async.options, options);\n\n      var WrapErrors = options.wrapErrors || function(errors) {\n        return errors;\n      };\n\n      // Removes unknown attributes\n      if (options.cleanAttributes !== false) {\n        attributes = v.cleanAttributes(attributes, constraints);\n      }\n\n      var results = v.runValidations(attributes, constraints, options);\n\n      return new v.Promise(function(resolve, reject) {\n        v.waitForResults(results).then(function() {\n          var errors = v.processValidationResults(results, options);\n          if (errors) {\n            reject(new WrapErrors(errors, options, attributes, constraints));\n          } else {\n            resolve(attributes);\n          }\n        }, function(err) {\n          reject(err);\n        });\n      });\n    },\n\n    single: function(value, constraints, options) {\n      options = v.extend({}, v.single.options, options, {\n        format: \"flat\",\n        fullMessages: false\n      });\n      return v({single: value}, {single: constraints}, options);\n    },\n\n    // Returns a promise that is resolved when all promises in the results array\n    // are settled. The promise returned from this function is always resolved,\n    // never rejected.\n    // This function modifies the input argument, it replaces the promises\n    // with the value returned from the promise.\n    waitForResults: function(results) {\n      // Create a sequence of all the results starting with a resolved promise.\n      return results.reduce(function(memo, result) {\n        // If this result isn't a promise skip it in the sequence.\n        if (!v.isPromise(result.error)) {\n          return memo;\n        }\n\n        return memo.then(function() {\n          return result.error.then(function(error) {\n            result.error = error || null;\n          });\n        });\n      }, new v.Promise(function(r) { r(); })); // A resolved promise\n    },\n\n    // If the given argument is a call: function the and: function return the value\n    // otherwise just return the value. Additional arguments will be passed as\n    // arguments to the function.\n    // Example:\n    // ```\n    // result('foo') // 'foo'\n    // result(Math.max, 1, 2) // 2\n    // ```\n    result: function(value) {\n      var args = [].slice.call(arguments, 1);\n      if (typeof value === 'function') {\n        value = value.apply(null, args);\n      }\n      return value;\n    },\n\n    // Checks if the value is a number. This function does not consider NaN a\n    // number like many other `isNumber` functions do.\n    isNumber: function(value) {\n      return typeof value === 'number' && !isNaN(value);\n    },\n\n    // Returns false if the object is not a function\n    isFunction: function(value) {\n      return typeof value === 'function';\n    },\n\n    // A simple check to verify that the value is an integer. Uses `isNumber`\n    // and a simple modulo check.\n    isInteger: function(value) {\n      return v.isNumber(value) && value % 1 === 0;\n    },\n\n    // Checks if the value is a boolean\n    isBoolean: function(value) {\n      return typeof value === 'boolean';\n    },\n\n    // Uses the `Object` function to check if the given argument is an object.\n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n\n    // Simply checks if the object is an instance of a date\n    isDate: function(obj) {\n      return obj instanceof Date;\n    },\n\n    // Returns false if the object is `null` of `undefined`\n    isDefined: function(obj) {\n      return obj !== null && obj !== undefined;\n    },\n\n    // Checks if the given argument is a promise. Anything with a `then`\n    // function is considered a promise.\n    isPromise: function(p) {\n      return !!p && v.isFunction(p.then);\n    },\n\n    isJqueryElement: function(o) {\n      return o && v.isString(o.jquery);\n    },\n\n    isDomElement: function(o) {\n      if (!o) {\n        return false;\n      }\n\n      if (!o.querySelectorAll || !o.querySelector) {\n        return false;\n      }\n\n      if (v.isObject(document) && o === document) {\n        return true;\n      }\n\n      // http://stackoverflow.com/a/384380/699304\n      /* istanbul ignore else */\n      if (typeof HTMLElement === \"object\") {\n        return o instanceof HTMLElement;\n      } else {\n        return o &&\n          typeof o === \"object\" &&\n          o !== null &&\n          o.nodeType === 1 &&\n          typeof o.nodeName === \"string\";\n      }\n    },\n\n    isEmpty: function(value) {\n      var attr;\n\n      // Null and undefined are empty\n      if (!v.isDefined(value)) {\n        return true;\n      }\n\n      // functions are non empty\n      if (v.isFunction(value)) {\n        return false;\n      }\n\n      // Whitespace only strings are empty\n      if (v.isString(value)) {\n        return v.EMPTY_STRING_REGEXP.test(value);\n      }\n\n      // For arrays we use the length property\n      if (v.isArray(value)) {\n        return value.length === 0;\n      }\n\n      // Dates have no attributes but aren't empty\n      if (v.isDate(value)) {\n        return false;\n      }\n\n      // If we find at least one property we consider it non empty\n      if (v.isObject(value)) {\n        for (attr in value) {\n          return false;\n        }\n        return true;\n      }\n\n      return false;\n    },\n\n    // Formats the specified strings with the given values like so:\n    // ```\n    // format(\"Foo: %{foo}\", {foo: \"bar\"}) // \"Foo bar\"\n    // ```\n    // If you want to write %{...} without having it replaced simply\n    // prefix it with % like this `Foo: %%{foo}` and it will be returned\n    // as `\"Foo: %{foo}\"`\n    format: v.extend(function(str, vals) {\n      if (!v.isString(str)) {\n        return str;\n      }\n      return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {\n        if (m1 === '%') {\n          return \"%{\" + m2 + \"}\";\n        } else {\n          return String(vals[m2]);\n        }\n      });\n    }, {\n      // Finds %{key} style patterns in the given string\n      FORMAT_REGEXP: /(%?)%\\{([^\\}]+)\\}/g\n    }),\n\n    // \"Prettifies\" the given string.\n    // Prettifying means replacing [.\\_-] with spaces as well as splitting\n    // camel case words.\n    prettify: function(str) {\n      if (v.isNumber(str)) {\n        // If there are more than 2 decimals round it to two\n        if ((str * 100) % 1 === 0) {\n          return \"\" + str;\n        } else {\n          return parseFloat(Math.round(str * 100) / 100).toFixed(2);\n        }\n      }\n\n      if (v.isArray(str)) {\n        return str.map(function(s) { return v.prettify(s); }).join(\", \");\n      }\n\n      if (v.isObject(str)) {\n        return str.toString();\n      }\n\n      // Ensure the string is actually a string\n      str = \"\" + str;\n\n      return str\n        // Splits keys separated by periods\n        .replace(/([^\\s])\\.([^\\s])/g, '$1 $2')\n        // Removes backslashes\n        .replace(/\\\\+/g, '')\n        // Replaces - and - with space\n        .replace(/[_-]/g, ' ')\n        // Splits camel cased words\n        .replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {\n          return \"\" + m1 + \" \" + m2.toLowerCase();\n        })\n        .toLowerCase();\n    },\n\n    stringifyValue: function(value) {\n      return v.prettify(value);\n    },\n\n    isString: function(value) {\n      return typeof value === 'string';\n    },\n\n    isArray: function(value) {\n      return {}.toString.call(value) === '[object Array]';\n    },\n\n    // Checks if the object is a hash, which is equivalent to an object that\n    // is neither an array nor a function.\n    isHash: function(value) {\n      return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);\n    },\n\n    contains: function(obj, value) {\n      if (!v.isDefined(obj)) {\n        return false;\n      }\n      if (v.isArray(obj)) {\n        return obj.indexOf(value) !== -1;\n      }\n      return value in obj;\n    },\n\n    unique: function(array) {\n      if (!v.isArray(array)) {\n        return array;\n      }\n      return array.filter(function(el, index, array) {\n        return array.indexOf(el) == index;\n      });\n    },\n\n    forEachKeyInKeypath: function(object, keypath, callback) {\n      if (!v.isString(keypath)) {\n        return undefined;\n      }\n\n      var key = \"\"\n        , i\n        , escape = false;\n\n      for (i = 0; i < keypath.length; ++i) {\n        switch (keypath[i]) {\n          case '.':\n            if (escape) {\n              escape = false;\n              key += '.';\n            } else {\n              object = callback(object, key, false);\n              key = \"\";\n            }\n            break;\n\n          case '\\\\':\n            if (escape) {\n              escape = false;\n              key += '\\\\';\n            } else {\n              escape = true;\n            }\n            break;\n\n          default:\n            escape = false;\n            key += keypath[i];\n            break;\n        }\n      }\n\n      return callback(object, key, true);\n    },\n\n    getDeepObjectValue: function(obj, keypath) {\n      if (!v.isObject(obj)) {\n        return undefined;\n      }\n\n      return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {\n        if (v.isObject(obj)) {\n          return obj[key];\n        }\n      });\n    },\n\n    // This returns an object with all the values of the form.\n    // It uses the input name as key and the value as value\n    // So for example this:\n    // <input type=\"text\" name=\"email\" value=\"foo@bar.com\" />\n    // would return:\n    // {email: \"foo@bar.com\"}\n    collectFormValues: function(form, options) {\n      var values = {}\n        , i\n        , j\n        , input\n        , inputs\n        , option\n        , value;\n\n      if (v.isJqueryElement(form)) {\n        form = form[0];\n      }\n\n      if (!form) {\n        return values;\n      }\n\n      options = options || {};\n\n      inputs = form.querySelectorAll(\"input[name], textarea[name]\");\n      for (i = 0; i < inputs.length; ++i) {\n        input = inputs.item(i);\n\n        if (v.isDefined(input.getAttribute(\"data-ignored\"))) {\n          continue;\n        }\n\n        value = v.sanitizeFormValue(input.value, options);\n        if (input.type === \"number\") {\n          value = value ? +value : null;\n        } else if (input.type === \"checkbox\") {\n          if (input.attributes.value) {\n            if (!input.checked) {\n              value = values[input.name] || null;\n            }\n          } else {\n            value = input.checked;\n          }\n        } else if (input.type === \"radio\") {\n          if (!input.checked) {\n            value = values[input.name] || null;\n          }\n        }\n        values[input.name] = value;\n      }\n\n      inputs = form.querySelectorAll(\"select[name]\");\n      for (i = 0; i < inputs.length; ++i) {\n        input = inputs.item(i);\n        if (input.multiple) {\n          value = [];\n          for (j in input.options) {\n            option = input.options[j];\n            if (option.selected) {\n              value.push(v.sanitizeFormValue(option.value, options));\n            }\n          }\n        } else {\n          value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);\n        }\n        values[input.name] = value;\n      }\n\n      return values;\n    },\n\n    sanitizeFormValue: function(value, options) {\n      if (options.trim && v.isString(value)) {\n        value = value.trim();\n      }\n\n      if (options.nullify !== false && value === \"\") {\n        return null;\n      }\n      return value;\n    },\n\n    capitalize: function(str) {\n      if (!v.isString(str)) {\n        return str;\n      }\n      return str[0].toUpperCase() + str.slice(1);\n    },\n\n    // Remove all errors who's error attribute is empty (null or undefined)\n    pruneEmptyErrors: function(errors) {\n      return errors.filter(function(error) {\n        return !v.isEmpty(error.error);\n      });\n    },\n\n    // In\n    // [{error: [\"err1\", \"err2\"], ...}]\n    // Out\n    // [{error: \"err1\", ...}, {error: \"err2\", ...}]\n    //\n    // All attributes in an error with multiple messages are duplicated\n    // when expanding the errors.\n    expandMultipleErrors: function(errors) {\n      var ret = [];\n      errors.forEach(function(error) {\n        // Removes errors without a message\n        if (v.isArray(error.error)) {\n          error.error.forEach(function(msg) {\n            ret.push(v.extend({}, error, {error: msg}));\n          });\n        } else {\n          ret.push(error);\n        }\n      });\n      return ret;\n    },\n\n    // Converts the error mesages by prepending the attribute name unless the\n    // message is prefixed by ^\n    convertErrorMessages: function(errors, options) {\n      options = options || {};\n\n      var ret = [];\n      errors.forEach(function(errorInfo) {\n        var error = v.result(errorInfo.error,\n            errorInfo.value,\n            errorInfo.attribute,\n            errorInfo.options,\n            errorInfo.attributes,\n            errorInfo.globalOptions);\n\n        if (!v.isString(error)) {\n          ret.push(errorInfo);\n          return;\n        }\n\n        if (error[0] === '^') {\n          error = error.slice(1);\n        } else if (options.fullMessages !== false) {\n          error = v.capitalize(v.prettify(errorInfo.attribute)) + \" \" + error;\n        }\n        error = error.replace(/\\\\\\^/g, \"^\");\n        error = v.format(error, {value: v.stringifyValue(errorInfo.value)});\n        ret.push(v.extend({}, errorInfo, {error: error}));\n      });\n      return ret;\n    },\n\n    // In:\n    // [{attribute: \"<attributeName>\", ...}]\n    // Out:\n    // {\"<attributeName>\": [{attribute: \"<attributeName>\", ...}]}\n    groupErrorsByAttribute: function(errors) {\n      var ret = {};\n      errors.forEach(function(error) {\n        var list = ret[error.attribute];\n        if (list) {\n          list.push(error);\n        } else {\n          ret[error.attribute] = [error];\n        }\n      });\n      return ret;\n    },\n\n    // In:\n    // [{error: \"<message 1>\", ...}, {error: \"<message 2>\", ...}]\n    // Out:\n    // [\"<message 1>\", \"<message 2>\"]\n    flattenErrorsToArray: function(errors) {\n      return errors\n        .map(function(error) { return error.error; })\n        .filter(function(value, index, self) {\n          return self.indexOf(value) === index;\n        });\n    },\n\n    cleanAttributes: function(attributes, whitelist) {\n      function whitelistCreator(obj, key, last) {\n        if (v.isObject(obj[key])) {\n          return obj[key];\n        }\n        return (obj[key] = last ? true : {});\n      }\n\n      function buildObjectWhitelist(whitelist) {\n        var ow = {}\n          , lastObject\n          , attr;\n        for (attr in whitelist) {\n          if (!whitelist[attr]) {\n            continue;\n          }\n          v.forEachKeyInKeypath(ow, attr, whitelistCreator);\n        }\n        return ow;\n      }\n\n      function cleanRecursive(attributes, whitelist) {\n        if (!v.isObject(attributes)) {\n          return attributes;\n        }\n\n        var ret = v.extend({}, attributes)\n          , w\n          , attribute;\n\n        for (attribute in attributes) {\n          w = whitelist[attribute];\n\n          if (v.isObject(w)) {\n            ret[attribute] = cleanRecursive(ret[attribute], w);\n          } else if (!w) {\n            delete ret[attribute];\n          }\n        }\n        return ret;\n      }\n\n      if (!v.isObject(whitelist) || !v.isObject(attributes)) {\n        return {};\n      }\n\n      whitelist = buildObjectWhitelist(whitelist);\n      return cleanRecursive(attributes, whitelist);\n    },\n\n    exposeModule: function(validate, root, exports, module, define) {\n      if (exports) {\n        if (module && module.exports) {\n          exports = module.exports = validate;\n        }\n        exports.validate = validate;\n      } else {\n        root.validate = validate;\n        if (validate.isFunction(define) && define.amd) {\n          define([], function () { return validate; });\n        }\n      }\n    },\n\n    warn: function(msg) {\n      if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(\"[validate.js] \" + msg);\n      }\n    },\n\n    error: function(msg) {\n      if (typeof console !== \"undefined\" && console.error) {\n        console.error(\"[validate.js] \" + msg);\n      }\n    }\n  });\n\n  validate.validators = {\n    // Presence validates that the value isn't empty\n    presence: function(value, options) {\n      options = v.extend({}, this.options, options);\n      if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {\n        return options.message || this.message || \"can't be blank\";\n      }\n    },\n    length: function(value, options, attribute) {\n      // Empty values are allowed\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var is = options.is\n        , maximum = options.maximum\n        , minimum = options.minimum\n        , tokenizer = options.tokenizer || function(val) { return val; }\n        , err\n        , errors = [];\n\n      value = tokenizer(value);\n      var length = value.length;\n      if(!v.isNumber(length)) {\n        v.error(v.format(\"Attribute %{attr} has a non numeric value for `length`\", {attr: attribute}));\n        return options.message || this.notValid || \"has an incorrect length\";\n      }\n\n      // Is checks\n      if (v.isNumber(is) && length !== is) {\n        err = options.wrongLength ||\n          this.wrongLength ||\n          \"is the wrong length (should be %{count} characters)\";\n        errors.push(v.format(err, {count: is}));\n      }\n\n      if (v.isNumber(minimum) && length < minimum) {\n        err = options.tooShort ||\n          this.tooShort ||\n          \"is too short (minimum is %{count} characters)\";\n        errors.push(v.format(err, {count: minimum}));\n      }\n\n      if (v.isNumber(maximum) && length > maximum) {\n        err = options.tooLong ||\n          this.tooLong ||\n          \"is too long (maximum is %{count} characters)\";\n        errors.push(v.format(err, {count: maximum}));\n      }\n\n      if (errors.length > 0) {\n        return options.message || errors;\n      }\n    },\n    numericality: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var errors = []\n        , name\n        , count\n        , checks = {\n            greaterThan:          function(v, c) { return v > c; },\n            greaterThanOrEqualTo: function(v, c) { return v >= c; },\n            equalTo:              function(v, c) { return v === c; },\n            lessThan:             function(v, c) { return v < c; },\n            lessThanOrEqualTo:    function(v, c) { return v <= c; },\n            divisibleBy:          function(v, c) { return v % c === 0; }\n          };\n\n      // Strict will check that it is a valid looking number\n      if (v.isString(value) && options.strict) {\n        var pattern = \"^(0|[1-9]\\\\d*)\";\n        if (!options.onlyInteger) {\n          pattern += \"(\\\\.\\\\d+)?\";\n        }\n        pattern += \"$\";\n\n        if (!(new RegExp(pattern).test(value))) {\n          return options.message ||\n            options.notValid ||\n            this.notValid ||\n            this.message ||\n            \"must be a valid number\";\n        }\n      }\n\n      // Coerce the value to a number unless we're being strict.\n      if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {\n        value = +value;\n      }\n\n      // If it's not a number we shouldn't continue since it will compare it.\n      if (!v.isNumber(value)) {\n        return options.message ||\n          options.notValid ||\n          this.notValid ||\n          this.message ||\n          \"is not a number\";\n      }\n\n      // Same logic as above, sort of. Don't bother with comparisons if this\n      // doesn't pass.\n      if (options.onlyInteger && !v.isInteger(value)) {\n        return options.message ||\n          options.notInteger ||\n          this.notInteger ||\n          this.message ||\n          \"must be an integer\";\n      }\n\n      for (name in checks) {\n        count = options[name];\n        if (v.isNumber(count) && !checks[name](value, count)) {\n          // This picks the default message if specified\n          // For example the greaterThan check uses the message from\n          // this.notGreaterThan so we capitalize the name and prepend \"not\"\n          var key = \"not\" + v.capitalize(name);\n          var msg = options[key] ||\n            this[key] ||\n            this.message ||\n            \"must be %{type} %{count}\";\n\n          errors.push(v.format(msg, {\n            count: count,\n            type: v.prettify(name)\n          }));\n        }\n      }\n\n      if (options.odd && value % 2 !== 1) {\n        errors.push(options.notOdd ||\n            this.notOdd ||\n            this.message ||\n            \"must be odd\");\n      }\n      if (options.even && value % 2 !== 0) {\n        errors.push(options.notEven ||\n            this.notEven ||\n            this.message ||\n            \"must be even\");\n      }\n\n      if (errors.length) {\n        return options.message || errors;\n      }\n    },\n    datetime: v.extend(function(value, options) {\n      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {\n        throw new Error(\"Both the parse and format functions needs to be set to use the datetime/date validator\");\n      }\n\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var err\n        , errors = []\n        , earliest = options.earliest ? this.parse(options.earliest, options) : NaN\n        , latest = options.latest ? this.parse(options.latest, options) : NaN;\n\n      value = this.parse(value, options);\n\n      // 86400000 is the number of seconds in a day, this is used to remove\n      // the time from the date\n      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {\n        err = options.notValid ||\n          options.message ||\n          this.notValid ||\n          \"must be a valid date\";\n        return v.format(err, {value: arguments[0]});\n      }\n\n      if (!isNaN(earliest) && value < earliest) {\n        err = options.tooEarly ||\n          options.message ||\n          this.tooEarly ||\n          \"must be no earlier than %{date}\";\n        err = v.format(err, {\n          value: this.format(value, options),\n          date: this.format(earliest, options)\n        });\n        errors.push(err);\n      }\n\n      if (!isNaN(latest) && value > latest) {\n        err = options.tooLate ||\n          options.message ||\n          this.tooLate ||\n          \"must be no later than %{date}\";\n        err = v.format(err, {\n          date: this.format(latest, options),\n          value: this.format(value, options)\n        });\n        errors.push(err);\n      }\n\n      if (errors.length) {\n        return v.unique(errors);\n      }\n    }, {\n      parse: null,\n      format: null\n    }),\n    date: function(value, options) {\n      options = v.extend({}, options, {dateOnly: true});\n      return v.validators.datetime.call(v.validators.datetime, value, options);\n    },\n    format: function(value, options) {\n      if (v.isString(options) || (options instanceof RegExp)) {\n        options = {pattern: options};\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var message = options.message || this.message || \"is invalid\"\n        , pattern = options.pattern\n        , match;\n\n      // Empty values are allowed\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (!v.isString(value)) {\n        return message;\n      }\n\n      if (v.isString(pattern)) {\n        pattern = new RegExp(options.pattern, options.flags);\n      }\n      match = pattern.exec(value);\n      if (!match || match[0].length != value.length) {\n        return message;\n      }\n    },\n    inclusion: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (v.isArray(options)) {\n        options = {within: options};\n      }\n      options = v.extend({}, this.options, options);\n      if (v.contains(options.within, value)) {\n        return;\n      }\n      var message = options.message ||\n        this.message ||\n        \"^%{value} is not included in the list\";\n      return v.format(message, {value: value});\n    },\n    exclusion: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (v.isArray(options)) {\n        options = {within: options};\n      }\n      options = v.extend({}, this.options, options);\n      if (!v.contains(options.within, value)) {\n        return;\n      }\n      var message = options.message || this.message || \"^%{value} is restricted\";\n      return v.format(message, {value: value});\n    },\n    email: v.extend(function(value, options) {\n      options = v.extend({}, this.options, options);\n      var message = options.message || this.message || \"is not a valid email\";\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (!v.isString(value)) {\n        return message;\n      }\n      if (!this.PATTERN.exec(value)) {\n        return message;\n      }\n    }, {\n      PATTERN: /^[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z]{2,}$/i\n    }),\n    equality: function(value, options, attribute, attributes) {\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      if (v.isString(options)) {\n        options = {attribute: options};\n      }\n      options = v.extend({}, this.options, options);\n      var message = options.message ||\n        this.message ||\n        \"is not equal to %{attribute}\";\n\n      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {\n        throw new Error(\"The attribute must be a non empty string\");\n      }\n\n      var otherValue = v.getDeepObjectValue(attributes, options.attribute)\n        , comparator = options.comparator || function(v1, v2) {\n          return v1 === v2;\n        };\n\n      if (!comparator(value, otherValue, options, attribute, attributes)) {\n        return v.format(message, {attribute: v.prettify(options.attribute)});\n      }\n    },\n\n    // A URL validator that is used to validate URLs with the ability to\n    // restrict schemes and some domains.\n    url: function(value, options) {\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var message = options.message || this.message || \"is not a valid url\"\n        , schemes = options.schemes || this.schemes || ['http', 'https']\n        , allowLocal = options.allowLocal || this.allowLocal || false;\n\n      if (!v.isString(value)) {\n        return message;\n      }\n\n      // https://gist.github.com/dperini/729294\n      var regex =\n        \"^\" +\n        // protocol identifier\n        \"(?:(?:\" + schemes.join(\"|\") + \")://)\" +\n        // user:pass authentication\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n        \"(?:\";\n\n      var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n\n      if (allowLocal) {\n        tld += \"?\";\n      } else {\n        regex +=\n          // IP address exclusion\n          // private & local networks\n          \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +\n          \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +\n          \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\";\n      }\n\n      regex +=\n          // IP address dotted notation octets\n          // excludes loopback network 0.0.0.0\n          // excludes reserved space >= 224.0.0.0\n          // excludes network & broacast addresses\n          // (first & last IP address of each class)\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n        \"|\" +\n          // host name\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n          // domain name\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n          tld +\n        \")\" +\n        // port number\n        \"(?::\\\\d{2,5})?\" +\n        // resource path\n        \"(?:[/?#]\\\\S*)?\" +\n      \"$\";\n\n      var PATTERN = new RegExp(regex, 'i');\n      if (!PATTERN.exec(value)) {\n        return message;\n      }\n    }\n  };\n\n  validate.formatters = {\n    detailed: function(errors) {return errors;},\n    flat: v.flattenErrorsToArray,\n    grouped: function(errors) {\n      var attr;\n\n      errors = v.groupErrorsByAttribute(errors);\n      for (attr in errors) {\n        errors[attr] = v.flattenErrorsToArray(errors[attr]);\n      }\n      return errors;\n    },\n    constraint: function(errors) {\n      var attr;\n      errors = v.groupErrorsByAttribute(errors);\n      for (attr in errors) {\n        errors[attr] = errors[attr].map(function(result) {\n          return result.validator;\n        }).sort();\n      }\n      return errors;\n    }\n  };\n\n  validate.exposeModule(validate, this, exports, module, define);\n}).call(this,\n        typeof exports !== 'undefined' ? /* istanbul ignore next */ exports : null,\n        typeof module !== 'undefined' ? /* istanbul ignore next */ module : null,\n        typeof define !== 'undefined' ? /* istanbul ignore next */ define : null);\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/Gruntfile.js":"module.exports = function(grunt) {\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    jshint: {\n      gruntfile: {\n        src: 'Gruntfile.js'\n      },\n      specs: {\n        src: 'specs/**/*.js',\n        options: {\n          ignores: ['specs/vendor/**/*.js'],\n          laxcomma: true,\n          curly: true\n        }\n      },\n      validate: {\n        src: '<%= pkg.name %>',\n        options: {\n          laxcomma: true,\n          curly: true\n        }\n      }\n    },\n    watch: {\n      jshintGruntfile: {\n        files: 'Gruntfile.js',\n        tasks: ['jshint:gruntfile'],\n        options: {\n          atBegin: true\n        }\n      },\n      jshintSrc: {\n        files: '<%= pkg.name %>',\n        tasks: ['jshint:validate'],\n        options: {\n          atBegin: true\n        }\n      },\n      jshintSpecs: {\n        files: 'specs/**/*.js',\n        tasks: ['jshint:specs'],\n        options: {\n          atBegin: true\n        }\n      },\n      specs: {\n        files: ['specs/**/*.js', '<%= pkg.name %>'],\n        tasks: ['jasmine:specs', 'jasmine:coverage'],\n        options: {\n          atBegin: true\n        }\n      }\n    },\n    jasmine: {\n      specs: {\n        src: \"<%= pkg.name %>\",\n        options: {\n          keepRunner: true,\n          vendor: \"specs/vendor/**/*.js\",\n          specs: \"specs/**/*-spec.js\",\n          helpers: \"specs/helpers.js\",\n          display: \"short\",\n          summary: true\n        }\n      },\n      coverage: {\n        src: \"<%= jasmine.specs.src %>\",\n        options: {\n          vendor: \"<%= jasmine.specs.options.vendor %>\",\n          specs: \"<%= jasmine.specs.options.specs %>\",\n          helpers: \"<%= jasmine.specs.options.helpers %>\",\n          display: \"none\",\n          template: require('grunt-template-jasmine-istanbul'),\n          templateOptions: {\n            coverage: 'coverage.json',\n            report: [{\n              type: 'text-summary'\n            }, {\n              type: 'lcovonly'\n            }, {\n              type: 'html',\n              options: {\n                dir: 'coverage'\n              }\n            }]\n          }\n        }\n      }\n    },\n    docco: {\n      src: \"<%= pkg.name %>\",\n      options: {\n        output: 'docs'\n      }\n    },\n    uglify: {\n      options: {\n        report: 'gzip',\n        banner: '/*!\\n' +\n                ' * <%= pkg.name %> <%= pkg.version %>\\n' +\n                ' * http://validatejs.org/\\n' +\n                ' * (c) 2013-2015 Nicklas Ansman, 2013 Wrapp\\n' +\n                ' * <%= pkg.name %> may be freely distributed under the MIT license.\\n' +\n                '*/\\n'\n      },\n      dist: {\n        src: \"<%= pkg.name %>\",\n        dest: \"validate.min.js\",\n        options: {\n          sourceMap: true,\n          sourceMapName: 'validate.min.map'\n        }\n      }\n    }\n  });\n\n  grunt.loadNpmTasks('grunt-contrib-jasmine');\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n  grunt.loadNpmTasks('grunt-docco');\n  grunt.loadNpmTasks('grunt-notify');\n\n  grunt.registerTask('default', 'watch');\n  grunt.registerTask('build', ['jshint:validate', 'jasmine:specs', 'uglify', 'docco']);\n  grunt.registerTask('test', ['jshint', 'jasmine']);\n};\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/helpers.js":"beforeEach(function() {\n  jasmine.addMatchers({\n    toHaveLength: function(util, customEqualityTesters) {\n      return {\n        compare: function(actual, expected) {\n          return {\n            pass: actual.length === expected\n          };\n        }\n      };\n    },\n    toHaveBeenCalledWithContext: function(util, customEqualityTesters) {\n      return {\n        compare: function(actual, expected) {\n          return {\n            pass: actual.calls.any(function(call) {\n              return call.object === expected;\n            })\n          };\n        }\n      };\n    },\n    toHaveItems: function(util, customEqualityTesters) {\n      return {\n        compare: function(actual, expected) {\n          if (actual.length != expected.length) {\n            return {pass: false};\n          }\n\n          var ret = {};\n          ret.pass = actual.every(function(a) {\n            var passed = expected.some(function(e) {\n              return util.equals(a, e, customEqualityTesters);\n            });\n            if (!passed) {\n              ret.message = \"Object wasn't found:\\n\" +\n                JSON.stringify(a, null, 2) + \"\\n\\nExpected:\\n\" +\n                JSON.stringify(expected, null, 2);\n            }\n            return passed;\n          });\n\n          return ret;\n        }\n      };\n    },\n    toBeInstanceOf: function(util, customEqualityTesters) {\n      return {\n        compare: function(actual, expected) {\n          return {\n            pass: actual instanceof expected\n          };\n        }\n      };\n    },\n    toBeAPromise: function(util, customEqualityTesters) {\n      return {\n        compare: function(actual, expected) {\n          return {\n            pass: actual && typeof actual.then === \"function\"\n          };\n        }\n      };\n    },\n    toBeANumber: function(util, customEqualityTesters) {\n      return {\n        compare: function(actual, expected) {\n          return {\n            pass: typeof actual === 'number' && !isNaN(actual)\n          };\n        }\n      };\n    }\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validate-async-spec.js":"describe(\"validate.async\", function() {\n  var error = null\n    , success = null\n    , Promise = validate.Promise;\n\n  beforeEach(function() {\n    success = jasmine.createSpy(\"success\");\n    error = jasmine.createSpy(\"error\");\n\n    validate.validators.asyncFailReject = function() {\n      return new validate.Promise(function(resolve, reject) {\n        setTimeout(function() {\n          reject(\"failz\");\n        }, 1);\n      });\n    };\n\n    validate.validators.asyncFail = function() {\n      return new validate.Promise(function(resolve, reject) {\n        setTimeout(function() {\n          resolve(\"failz\");\n        }, 1);\n      });\n    };\n\n    validate.validators.asyncSuccess = function() {\n      return new validate.Promise(function(resolve, reject) {\n        setTimeout(function() {\n          resolve();\n        }, 1);\n      });\n    };\n  });\n\n  afterEach(function() {\n    delete validate.validators.asyncFailReject;\n    delete validate.validators.asyncFail;\n    delete validate.validators.asyncSuccess;\n    delete validate.validators.asyncError;\n    delete validate.async.options;\n    validate.Promise = Promise;\n  });\n\n  it(\"makes validate return a promise\", function() {\n    var promise = validate.async({}, {});\n    expect(promise).toBeAPromise();\n  });\n\n  it(\"throws an error if no promise is found\", function() {\n    delete validate.Promise;\n    expect(function() {\n      validate.async({}, {});\n    }).toThrow();\n  });\n\n  it(\"allows you to specify a custom Promise implementation\", function() {\n    spyOn(validate, \"Promise\").and.callFake(function(func) {\n      return new Promise(func);\n    });\n    var promise = validate.async({}, {});\n    expect(validate.Promise).toHaveBeenCalled();\n  });\n\n  it.promise(\"resolves the promise if all constraints pass\", function() {\n    var attrs = {foo: \"bar\"}\n      , constraints = {foo: {presence: true}};\n    return validate.async(attrs, constraints).then(success, error).then(function() {\n      expect(error).not.toHaveBeenCalled();\n      expect(success).toHaveBeenCalledWith(attrs);\n    });\n  });\n\n  it.promise(\"rejects the promise if any constraint fails\", function() {\n    var c = {name: {presence: true}};\n    return validate.async({}, c).then(success, error).then(function() {\n      expect(success).not.toHaveBeenCalled();\n      expect(error).toHaveBeenCalled();\n    });\n  });\n\n  it.promise(\"handles validators returning a promise\", function() {\n    var c = {\n      name: {\n        asyncFail: true,\n        asyncSuccess: true\n      }\n    };\n    return validate.async({}, c).then(success, error).then(function() {\n      expect(success).not.toHaveBeenCalled();\n      expect(error).toHaveBeenCalledWith({\n        name: [\"Name failz\"]\n      });\n    });\n  });\n\n  it.promise('handles validators resolving a promise with error', function() {\n    var c = {\n      name: {\n        asyncFail: true\n      }\n    };\n    return validate.async({}, c).then(success, error).then(function() {\n      expect(error).toHaveBeenCalledWith({\n        name: [\"Name failz\"]\n      });\n    });\n  });\n\n  it.promise(\"supports fullMessages: false\", function() {\n    var c = {name: {presence: true}};\n    return validate.async({}, c, {fullMessages: false}).then(success, error).then(function() {\n      expect(success).not.toHaveBeenCalled();\n      expect(error).toHaveBeenCalledWith({\n        name: [\"can't be blank\"]\n      });\n    });\n  });\n\n  describe(\"waitForResults\", function() {\n    var error, success;\n\n    beforeEach(function() {\n      error = jasmine.createSpy(\"error handler\");\n      success = jasmine.createSpy(\"success handler\");\n    });\n\n    it.promise(\"handles no results\", function() {\n      return validate.waitForResults([]);\n    });\n\n    it.promise(\"handles results with no promises\", function() {\n      var results = [{attribute: \"foo\", error: \"bar\"}];\n      return validate.waitForResults(results).then(function() {\n        expect(results).toEqual([{attribute: \"foo\", error: \"bar\"}]);\n      });\n    });\n\n    it.promise(\"handles results with promises\", function() {\n      var results = [{\n        attribute: \"foo\",\n        error: new validate.Promise(function(resolve, reject) {\n          setTimeout(resolve, 1);\n        })\n      }, {\n        attribute: \"bar\",\n        error: new validate.Promise(function(resolve, reject) {\n          setTimeout(resolve.bind(this, \"My error\"), 1);\n        })\n      }, {\n        attribute: \"baz\",\n        error: 4711\n      }];\n\n      return validate.waitForResults(results).then(function() {\n        expect(results).toEqual([{\n          attribute: \"foo\",\n          error: null\n        }, {\n          attribute: \"bar\",\n          error: \"My error\"\n        }, {\n          attribute: \"baz\",\n          error: 4711\n        }]);\n      });\n    });\n\n    it.promise(\"rejects the promise if any promise throw an exception\", function() {\n      var results = [{\n        attribute: \"foo\",\n        error: new validate.Promise(function(res, rej) { res(); })\n      }, {\n        attribute: \"bar\",\n        error: new validate.Promise(function(resolve, reject) {\n          throw new Error(\"Error\");\n        })\n      }, {\n        attribute: \"baz\",\n        error: new validate.Promise(function(res, rej) { res(); })\n      }];\n\n      return validate.waitForResults(results).then(success, error).then(function() {\n        expect(success).not.toHaveBeenCalled();\n        expect(error).toHaveBeenCalledWith(new Error(\"Error\"));\n      });\n    });\n  });\n\n  it.promise(\"allows default options\", function() {\n    validate.async.options = {format: \"flat\"};\n    var c = {name: {presence: true}}\n      , options = {foo: \"bar\"};\n    return validate.async({}, c, options).then(success, error).then(function() {\n      expect(success).not.toHaveBeenCalled();\n      expect(error).toHaveBeenCalledWith([\"Name can't be blank\"]);\n      expect(options).toEqual({foo: \"bar\"});\n      expect(validate.async.options).toEqual({format: \"flat\"});\n    });\n  });\n\n  it.promise(\"rejects the promise with an error if an exception is thrown\", function() {\n    var c = {\n      attribute: {\n        asyncError: true\n      }\n    };\n    validate.validators.asyncError = function() {\n      return new Promise(function(resolve, reject) {\n        reject(new Error(\"Some error\"));\n      });\n    };\n\n    return validate.async({}, c).then(success, error).then(function() {\n      expect(success).not.toHaveBeenCalled();\n      expect(error).toHaveBeenCalledWith(new Error(\"Some error\"));\n    });\n  });\n\n  it.promise(\"cleans the attributes per default\", function() {\n    var attrs = {foo: \"bar\"}\n      , constraints = {bar: {presence: true}}\n      , cleaned = {bar: \"foo\"};\n\n    spyOn(validate, \"cleanAttributes\").and.returnValue(cleaned);\n\n    return validate.async(attrs, constraints).then(success, error).then(function() {\n      expect(error).not.toHaveBeenCalled();\n      expect(success).toHaveBeenCalledWith(cleaned);\n      expect(validate.cleanAttributes).toHaveBeenCalledWith(attrs, constraints);\n    });\n  });\n\n  it.promise(\"doesn't cleans the attributes is cleanAttributes: false\", function() {\n    var attrs = {foo: \"bar\"}\n      , constraints = {foo: {presence: true}}\n      , cleaned = {bar: \"foo\"};\n\n    spyOn(validate, \"cleanAttributes\").and.returnValue(cleaned);\n\n    return validate.async(attrs, constraints, {cleanAttributes: false}).then(success, error).then(function() {\n      expect(error).not.toHaveBeenCalled();\n      expect(success).toHaveBeenCalledWith(attrs);\n      expect(validate.cleanAttributes).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"wrapping errors\", function() {\n    it.promise(\"it allows you to wrap errors using a custom function\", function() {\n      validate.async.options = {someOption: \"someValue\"};\n\n      var attrs = {foo: \"bar\", bar: \"foo\"}\n        , originalConstraints = {foo: {numericality: true}}\n        , wrapped = {attr: [\"errors\"]}\n        , wrapper = jasmine.createSpy(\"wrapper\").and.callFake(function(errors, options, attributes, constraints) {\n            expect(errors).toEqual({foo: [\"Foo is not a number\"]});\n            // The options should have been merged with the default options\n            expect(options).toEqual({\n              wrapErrors: wrapper,\n              someOption: \"someValue\"\n            });\n            expect(attributes).toEqual({foo: \"bar\"});\n            expect(constraints).toBe(originalConstraints);\n            return wrapped;\n          })\n        , originalOptions = {wrapErrors: wrapper};\n\n      return validate.async(attrs, originalConstraints, originalOptions).then(success, error).then(function() {\n        expect(wrapper).toHaveBeenCalled();\n        expect(error).toHaveBeenCalledWith(wrapped);\n        expect(success).not.toHaveBeenCalled();\n      });\n    });\n\n    it.promise(\"calls the wrapper function with the new keyword\", function() {\n      var wrapper = jasmine.createSpy(\"wrapper\").and.callFake(function(errors) {\n        expect(this.constructor).toBe(wrapper);\n        return errors;\n      });\n\n      return validate.async({}, {foo: {presence: true}}, {wrapErrors: wrapper}).then(success, error).then(function() {\n        expect(error).toHaveBeenCalled();\n        expect(success).not.toHaveBeenCalled();\n        expect(wrapper).toHaveBeenCalled();\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validate-helpers-spec.js":"describe(\"validate\", function() {\n  describe('extend', function() {\n    it(\"extends the first argument with the remaining arguments\", function() {\n      var obj = {};\n      validate.extend(obj, {foo: \"foo\"}, {bar: \"bar\"});\n      expect(obj).toEqual({foo: \"foo\", bar: \"bar\"});\n    });\n\n    it(\"returns the first argument\", function() {\n      var obj = {};\n      expect(validate.extend(obj)).toBe(obj);\n    });\n\n    it(\"extends with the seconds argument first\", function() {\n      var actual = validate.extend({}, {foo: \"foo\"}, {foo: \"bar\"});\n      expect(actual).toEqual({foo: \"bar\"});\n    });\n  });\n\n  describe('result', function() {\n    it(\"returns the first argument if it's not a function\", function() {\n      var obj = {};\n      expect(validate.result(obj)).toBe(obj);\n    });\n\n    it(\"calls the argument if it's a function and returns the result\", function() {\n      var obj = jasmine.createSpy().and.returnValue(\"some return value\");\n      expect(validate.result(obj)).toEqual(\"some return value\");\n    });\n\n    it(\"accepts additional arguments as arguments to the function\", function() {\n      var obj = jasmine.createSpy();\n      validate.result(obj, \"foo\", \"bar\", \"baz\");\n      expect(obj).toHaveBeenCalledWith(\"foo\", \"bar\", \"baz\");\n    });\n  });\n\n  describe('isNumber', function() {\n    it(\"returns true for numbers\", function() {\n      expect(validate.isNumber(0)).toBe(true);\n      expect(validate.isNumber(1)).toBe(true);\n      expect(validate.isNumber(Math.PI)).toBe(true);\n    });\n\n    it(\"returns false for non numbers\", function() {\n      expect(validate.isNumber(null)).toBe(false);\n      expect(validate.isNumber(true)).toBe(false);\n      expect(validate.isNumber(\"1\")).toBe(false);\n    });\n  });\n\n  describe('isInteger', function() {\n    it(\"returns true for integers\", function() {\n      expect(validate.isInteger(0)).toBe(true);\n      expect(validate.isInteger(1)).toBe(true);\n    });\n\n    it(\"returns false for floats and other types \", function() {\n      expect(validate.isInteger(Math.PI)).toBe(false);\n      expect(validate.isInteger(null)).toBe(false);\n      expect(validate.isInteger(\"1\")).toBe(false);\n    });\n  });\n\n  describe('isBoolean', function() {\n    it(\"returns true for booleans\", function() {\n      expect(validate.isBoolean(true)).toBe(true);\n      expect(validate.isBoolean(false)).toBe(true);\n    });\n\n    it(\"returns false for non booleans \", function() {\n      expect(validate.isBoolean(null)).toBe(false);\n      expect(validate.isBoolean({})).toBe(false);\n      expect(validate.isBoolean({foo: \"bar\"})).toBe(false);\n      expect(validate.isBoolean([])).toBe(false);\n      expect(validate.isBoolean(\"\")).toBe(false);\n      expect(validate.isBoolean(function() {})).toBe(false);\n    });\n  });\n\n  describe('isObject', function() {\n    it(\"returns true for objects\", function() {\n      expect(validate.isObject({})).toBe(true);\n      expect(validate.isObject({foo: \"bar\"})).toBe(true);\n      expect(validate.isObject([])).toBe(true);\n      expect(validate.isObject(function() {})).toBe(true);\n    });\n\n    it(\"returns false for non objects\", function() {\n      expect(validate.isObject(null)).toBe(false);\n      expect(validate.isObject(1)).toBe(false);\n      expect(validate.isObject(\"\")).toBe(false);\n      expect(validate.isObject(false)).toBe(false);\n    });\n  });\n\n  describe('isDefined', function() {\n    it(\"returns false for null and undefined\", function() {\n      expect(validate.isDefined(null)).toBe(false);\n      expect(validate.isDefined(undefined)).toBe(false);\n    });\n\n    it(\"returns true for other values\", function() {\n      expect(validate.isDefined(true)).toBe(true);\n      expect(validate.isDefined(0)).toBe(true);\n      expect(validate.isDefined(\"\")).toBe(true);\n    });\n  });\n\n  describe(\"isPromise\", function() {\n    it(\"returns false for null and undefined\", function() {\n      expect(validate.isPromise(null)).toBe(false);\n      expect(validate.isPromise(undefined)).toBe(false);\n    });\n\n    it(\"returns false for objects\", function() {\n      expect(validate.isPromise({})).toBe(false);\n    });\n\n    it(\"returns true for objects with a then function\", function() {\n      expect(validate.isPromise({then: \"that\"})).toBe(false);\n      expect(validate.isPromise({then: function() {}})).toBe(true);\n    });\n  });\n\n  describe('format', function() {\n    it(\"replaces %{...} with the correct value\", function() {\n      var actual = validate.format(\"Foo is %{foo}, bar is %{bar}\", {\n        foo: \"foo\",\n        bar: \"bar\"\n      });\n      expect(actual).toEqual(\"Foo is foo, bar is bar\");\n    });\n\n    it(\"can replace the same value multiple times\", function() {\n      var actual = validate.format(\"%{foo} %{foo}\", {foo: \"foo\"});\n      expect(actual).toEqual(\"foo foo\");\n    });\n\n    it(\"supports escaping %\", function() {\n      var actual = validate.format(\"Foo is %%{foo}\", {foo: \"foo\"});\n      expect(actual).toEqual(\"Foo is %{foo}\");\n    });\n\n    it(\"handles non strings as the message\", function() {\n      var obj = {foo: \"bar\"};\n      expect(validate.format(obj, {attr: \"value\"})).toBe(obj);\n    });\n  });\n\n  describe(\"stringifyValue\", function() {\n    it(\"simply calls validate.prettify\", function() {\n      spyOn(validate, \"prettify\").and.returnValue(\"foobar\");\n      expect(validate.stringifyValue(\"barfoo\")).toEqual(\"foobar\");\n      expect(validate.prettify).toHaveBeenCalledWith(\"barfoo\");\n    });\n  });\n\n  describe('prettify', function() {\n    it(\"lower cases the entire string\", function() {\n      expect(validate.prettify(\"FOO BAR\")).toEqual(\"foo bar\");\n    });\n\n    it(\"replaces underscores with spaces\", function() {\n      expect(validate.prettify(\"foo_bar_baz\")).toEqual(\"foo bar baz\");\n    });\n\n    it(\"replaces dashes with spaces\", function() {\n      expect(validate.prettify(\"foo-bar-baz\")).toEqual(\"foo bar baz\");\n    });\n\n    it(\"splits camel cased words\", function() {\n      expect(validate.prettify(\"fooBar\")).toEqual(\"foo bar\");\n    });\n\n    it(\"replaces periods with spaces if no space follows\", function() {\n      expect(validate.prettify(\"foo.bar.baz\")).toEqual(\"foo bar baz\");\n      expect(validate.prettify(\"foo. bar\")).toEqual(\"foo. bar\");\n      expect(validate.prettify(\"foo .bar\")).toEqual(\"foo .bar\");\n      expect(validate.prettify(\"foo.bar.\")).toEqual(\"foo bar.\");\n    });\n\n    it(\"replaces backslashes with nothing\", function() {\n      expect(validate.prettify(\"foo\\\\.bar\\\\.baz\")).toEqual(\"foo bar baz\");\n      expect(validate.prettify(\"foo\\\\\\\\.bar\")).toEqual(\"foo bar\");\n    });\n\n    it(\"calls toString on objects\", function() {\n      var object = {\n          toString: function() { return \"Custom string\"; }\n        };\n\n      expect(validate.prettify(object)).toEqual(\"Custom string\");\n    });\n\n    it(\"doesn't allow too many decimals\", function() {\n      expect(validate.prettify(4711)).toEqual(\"4711\");\n      expect(validate.prettify(4711.2)).toEqual(\"4711.2\");\n      expect(validate.prettify(4711.255555)).toEqual(\"4711.26\");\n    });\n\n    it(\"handles arrays\", function() {\n      var array = [\"foo\", \"bar_baz\"];\n      // It valls it recusively\n      spyOn(validate, \"prettify\").and.callThrough();\n      expect(validate.prettify(array)).toEqual(\"foo, bar baz\");\n      expect(validate.prettify).toHaveBeenCalledWith(array);\n      expect(validate.prettify).toHaveBeenCalledWith(\"foo\");\n      expect(validate.prettify).toHaveBeenCalledWith(\"bar_baz\");\n    });\n  });\n\n  describe('isString', function() {\n    it(\"returns true for strings\", function() {\n      expect(validate.isString(\"foobar\")).toBe(true);\n      expect(validate.isString(\"\")).toBe(true);\n    });\n\n    it(\"returns false for non strings\", function() {\n      var obj = {toString: function() { return \"foobar\"; }};\n      expect(validate.isString(obj)).toBe(false);\n      expect(validate.isString(null)).toBe(false);\n      expect(validate.isString(true)).toBe(false);\n    });\n  });\n\n  describe('isArray', function() {\n    var isArray = validate.isArray;\n\n    it(\"returns true for arrays\", function() {\n      expect(isArray([])).toBe(true);\n      expect(isArray([1])).toBe(true);\n      expect(isArray([1, 2])).toBe(true);\n    });\n\n    it(\"returns false for non arrays\", function() {\n      expect(isArray({})).toBe(false);\n      expect(isArray(null)).toBe(false);\n      expect(isArray(1)).toBe(false);\n      expect(isArray(true)).toBe(false);\n    });\n  });\n\n  describe('isHash', function() {\n    it(\"returns true for hashes\", function() {\n      expect(validate.isHash({})).toBe(true);\n      expect(validate.isHash({foo: \"bar\"})).toBe(true);\n    });\n\n    it(\"returns false for non hashes\", function() {\n      expect(validate.isHash([])).toBe(false);\n      expect(validate.isHash(function() {})).toBe(false);\n      expect(validate.isHash(null)).toBe(false);\n      expect(validate.isHash(1)).toBe(false);\n      expect(validate.isHash(\"\")).toBe(false);\n      expect(validate.isHash(false)).toBe(false);\n    });\n  });\n\n  describe('contains', function() {\n    var contains = validate.contains;\n\n    it(\"returns false when not passing in a target object\", function() {\n      expect(contains(null, \"foo\")).toBe(false);\n      expect(contains(undefined, \"foo\")).toBe(false);\n    });\n\n    describe(\"arrays\", function() {\n      it(\"returns true if the value is in the specified array\", function() {\n        expect(contains([\"foo\", \"bar\", \"baz\"], \"foo\")).toBe(true);\n        expect(contains([\"foo\", \"bar\", \"baz\"], \"bar\")).toBe(true);\n        expect(contains([\"foo\", \"bar\", \"baz\"], \"baz\")).toBe(true);\n      });\n\n      it(\"returns false if the value is not in the specified array\", function() {\n        expect(contains([\"foo\", \"bar\", \"baz\"], \"quux\")).toBe(false);\n        expect(contains([\"foo\", \"bar\", \"baz\"], false)).toBe(false);\n        expect(contains([\"foo\", \"bar\", \"baz\"], 0)).toBe(false);\n        expect(contains([\"foo\", \"bar\", \"baz\"], null)).toBe(false);\n      });\n\n      it(\"works with empty arrays\", function() {\n        expect(contains([], \"foo\")).toBe(false);\n      });\n    });\n\n    describe(\"objects\", function() {\n      it(\"returns true if the value is a key in the object\", function() {\n        expect(contains({foo: false, bar: \"bar\"}, \"foo\")).toBe(true);\n        expect(contains({foo: false, bar: \"bar\"}, \"bar\")).toBe(true);\n      });\n\n      it(\"returns false if the value is not a key in the object\", function() {\n        expect(contains({foo: false, bar: \"bar\"}, \"quux\")).toBe(false);\n        expect(contains({foo: false, bar: \"bar\"}, null)).toBe(false);\n        expect(contains({foo: false, bar: \"bar\"}, 1)).toBe(false);\n        expect(contains({foo: false, bar: \"bar\"}, true)).toBe(false);\n      });\n\n      it(\"works with empty objects\", function() {\n        expect(contains({}, \"foo\")).toBe(false);\n      });\n    });\n  });\n\n  describe('capitalize', function() {\n    var capitalize = validate.capitalize;\n\n    it(\"captializes the first word\", function() {\n      expect(capitalize(\"foo\")).toEqual(\"Foo\");\n      expect(capitalize(\"foo bar\")).toEqual(\"Foo bar\");\n      expect(capitalize(\"foo bar baz\")).toEqual(\"Foo bar baz\");\n    });\n\n    it(\"returns the value for non strings\", function() {\n      var o = {foo: \"bar\"};\n      expect(capitalize(o)).toEqual(o);\n    });\n  });\n\n  describe(\"pruneEmptyErrors\", function() {\n    it(\"removes empty errors\", function() {\n      var input = [{\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail\",\n          options: {\"someOption\": \"someValue\"},\n          error: \"foobar\"\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail2\",\n          options: true,\n          error: [\"foo\", \"bar\"]\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"pass\",\n          options: true,\n          error: null\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"pass\",\n          options: true,\n          error: []\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"pass\",\n          options: true,\n          error: \"\"\n      }];\n\n      expect(validate.pruneEmptyErrors(input)).toEqual([{\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail\",\n          options: {\"someOption\": \"someValue\"},\n          error: \"foobar\"\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail2\",\n          options: true,\n          error: [\"foo\", \"bar\"]\n      }]);\n    });\n  });\n\n  describe(\"expandMultipleErrors\", function() {\n    it(\"expands error arrays to multiple entries\", function() {\n      var input = [{\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail\",\n          options: {\"someOption\": \"someValue\"},\n          error: \"foobar\"\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail2\",\n          options: true,\n          error: [\"foo\", \"bar\"]\n      }];\n\n      expect(validate.expandMultipleErrors(input)).toEqual([{\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail\",\n          options: {\"someOption\": \"someValue\"},\n          error: \"foobar\"\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail2\",\n          options: true,\n          error: \"foo\"\n        }, {\n          attribute: \"name\",\n          value: \"test\",\n          validator: \"fail2\",\n          options: true,\n          error: \"bar\"\n      }]);\n    });\n  });\n\n  describe('convertErrorMessages', function() {\n    var convertErrorMessages = validate.convertErrorMessages;\n\n    it(\"prettifies and prepends the attribute\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"can't be blank\",\n        someOtherProperty: \"someOtherProperty\",\n        value: \"foobar\"\n      }, {\n        attribute: \"foo_bar\",\n        error: \"has some other problem\",\n        value: \"foobar\"\n      }];\n\n      expect(convertErrorMessages(errors)).toEqual([{\n        attribute: \"foo\",\n        error: \"Foo can't be blank\",\n        someOtherProperty: \"someOtherProperty\",\n        value: \"foobar\"\n      }, {\n        attribute: \"foo_bar\",\n        error: \"Foo bar has some other problem\",\n        value: \"foobar\"\n      }]);\n    });\n\n    it(\"doesn't modify the input\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"can't be blank\",\n        value: \"foobar\"\n      }];\n      convertErrorMessages(errors);\n      expect(errors).toEqual([{\n        attribute: \"foo\",\n        error: \"can't be blank\",\n        value: \"foobar\"\n      }]);\n    });\n\n    it(\"returns an empty object if there are no errors\", function() {\n      expect(convertErrorMessages([])).toEqual([]);\n    });\n\n    it(\"doesn't prepend the attribute name if the message starts with a ^\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"^Please don't do that\",\n        value: \"foobar\"\n      }];\n      expect(convertErrorMessages(errors)).toEqual([{\n        attribute: \"foo\",\n        error: \"Please don't do that\",\n        value: \"foobar\"\n      }]);\n    });\n\n    it(\"handles an escaped ^\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"\\\\^ has a weird message^\\\\^\",\n        value: \"foobar\"\n      }];\n      expect(convertErrorMessages(errors)).toEqual([{\n        attribute: \"foo\",\n        error: \"Foo ^ has a weird message^^\",\n        value: \"foobar\"\n      }]);\n    });\n\n    it(\"doesn't prepend the attribute name if fullMessages is false\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"Please don't do that\",\n        value: \"foobar\"\n      }];\n      expect(convertErrorMessages(errors, {fullMessages: false})).toEqual([{\n        attribute: \"foo\",\n        error: \"Please don't do that\",\n        value: \"foobar\"\n      }]);\n    });\n\n    it(\"still strips the leading ^ even if fullmessages if false\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"\\\\^ has a weird message^\\\\^\",\n        value: \"foobar\"\n      }];\n      expect(convertErrorMessages(errors, {fullMessages: false})).toEqual([{\n        attribute: \"foo\",\n        error: \"^ has a weird message^^\",\n        value: \"foobar\"\n      }]);\n    });\n\n    it(\"allow messages to contain %{value}\", function() {\n      var errors = [{\n        attribute: \"foo\",\n        error: \"foo %{value}\",\n        someOtherProperty: \"someOtherProperty\",\n        value: \"foobar\"\n      }];\n\n      spyOn(validate, \"format\").and.callThrough();\n      spyOn(validate, \"stringifyValue\").and.returnValue(\"barfoo\");\n\n      expect(convertErrorMessages(errors)).toEqual([{\n        attribute: \"foo\",\n        error: \"Foo foo barfoo\",\n        someOtherProperty: \"someOtherProperty\",\n        value: \"foobar\"\n      }]);\n      expect(validate.format).toHaveBeenCalledWith(\"Foo foo %{value}\", {\n        value: \"barfoo\"\n      });\n    });\n  });\n\n  describe(\"groupErrorsByAttribute\", function() {\n    it(\"groups errors by attribute\", function() {\n      var input = [{\n          attribute: \"foo\",\n          someKey: \"someValue\"\n        }, {\n          attribute: \"bar\",\n          someOtherKey: \"someOtherValue\"\n        }, {\n          attribute: \"foo\",\n          someThirdKey: \"someThirdValue\"\n      }];\n\n      expect(validate.groupErrorsByAttribute(input)).toEqual({\n        foo: [{\n          attribute: \"foo\",\n          someKey: \"someValue\"\n        }, {\n          attribute: \"foo\",\n          someThirdKey: \"someThirdValue\"\n        }],\n        bar: [{\n          attribute: \"bar\",\n          someOtherKey: \"someOtherValue\"\n        }]\n      });\n    });\n  });\n\n  describe(\"processValidationResults\", function() {\n    var pvr = validate.processValidationResults;\n\n    it(\"allows the validator to return a string\", function() {\n      var results = [{attribute: \"name\", error: \"foobar\"}];\n      expect(pvr(results, {})).toEqual({name: [\"Name foobar\"]});\n    });\n\n    it(\"allows the validator to return an array\", function() {\n      var results = [{attribute: \"name\", error: [\"foo\", \"bar\"]}];\n      expect(pvr(results, {})).toEqual({name: [\"Name foo\", \"Name bar\"]});\n    });\n\n    it(\"supports multiple entries for the same attribute\", function() {\n      var results = [\n        {attribute: \"name\", error: [\"foo\", \"bar\"]},\n        {attribute: \"name\", error: \"baz\"}\n      ];\n      expect(pvr(results, {})).toEqual({\n        name: [\"Name foo\", \"Name bar\", \"Name baz\"]\n      });\n    });\n\n    it(\"the correct functions\", function() {\n      spyOn(validate, \"pruneEmptyErrors\").and.returnValue(\"pruned\");\n      spyOn(validate, \"expandMultipleErrors\").and.returnValue(\"expanded\");\n      spyOn(validate, \"convertErrorMessages\").and.returnValue([]);\n      var options = {option: \"value\"};\n      expect(pvr(\"input\", options)).toBe(undefined);\n\n      expect(validate.pruneEmptyErrors)\n        .toHaveBeenCalledWith(\"input\", options);\n      expect(validate.expandMultipleErrors)\n        .toHaveBeenCalledWith(\"pruned\", options);\n      expect(validate.convertErrorMessages)\n        .toHaveBeenCalledWith(\"expanded\", options);\n    });\n\n    it(\"throws an error for unknown formats\", function() {\n      expect(function() {\n        pvr([], {format: \"foobar\"});\n      }).toThrow(new Error(\"Unknown format foobar\"));\n    });\n  });\n\n  describe(\"flattenErrorsToArray\", function() {\n    it(\"flattens an array of errors objects to just the messages\", function() {\n      var input = [{\n        error: \"error 1\",\n        someKey: \"someValue\"\n      }, {\n        error: \"error 2\"\n      }];\n      expect(validate.flattenErrorsToArray(input)).toEqual([\n        \"error 1\",\n        \"error 2\"\n      ]);\n    });\n  });\n\n  describe('isFunction', function() {\n    var isFunction = validate.isFunction;\n\n    it(\"returns true for functions\", function() {\n      expect(isFunction(function() {})).toBe(true);\n    });\n\n    it(\"returns false for non functions\", function() {\n      expect(isFunction({})).toBe(false);\n      expect(isFunction(null)).toBe(false);\n      expect(isFunction(1)).toBe(false);\n      expect(isFunction(true)).toBe(false);\n    });\n  });\n\n  describe('exposeModule', function() {\n    var exposeModule = validate.exposeModule;\n\n    it(\"supports simple browser inclusion\", function() {\n      var root = {};\n      exposeModule(validate, root, null, null, null);\n      expect(root.validate).toBe(validate);\n    });\n\n    it(\"supports AMD\", function() {\n      var root = {}\n        , define = function(deps, func) {\n          expect(deps).toEqual([]);\n          expect(func()).toBe(validate);\n        };\n\n      var defineSpy = jasmine.createSpy('define').and.callFake(define);\n\n      exposeModule(validate, root, null, null, defineSpy);\n      expect(defineSpy).not.toHaveBeenCalled();\n\n      defineSpy.amd = true;\n\n      exposeModule(validate, root, null, null, defineSpy);\n\n      expect(defineSpy).toHaveBeenCalled();\n\n      // It should still expose it through the root\n      expect(root.validate).toBe(validate);\n    });\n\n    it(\"supports exports\", function() {\n      var root = {}\n        , exports = {};\n\n      exposeModule(validate, root, exports, null, null);\n\n      expect(root).toEqual({});\n      expect(exports.validate).toBe(validate);\n    });\n\n    it(\"supports module.exports\", function() {\n      var root = {}\n        , exports = {}\n        , module = {exports: true};\n\n      exposeModule(validate, root, exports, module, null);\n\n      expect(root).toEqual({});\n      expect(module.exports).toEqual(validate);\n      expect(module.exports.validate).toEqual(validate);\n    });\n  });\n\n  describe(\"warn\", function() {\n    var console = window.console;\n\n    beforeEach(function() {\n      window.console = undefined;\n    });\n\n    afterEach(function() {\n      window.console = console;\n    });\n\n    it(\"does nothing if the console isn't defined\", function() {\n      expect(function() { validate.warn(\"Msg\"); }).not.toThrow();\n    });\n\n    it(\"calls console.warn if defined\", function() {\n      window.console = {\n        warn: jasmine.createSpy(\"warn\")\n      };\n      validate.warn(\"Msg\");\n      expect(window.console.warn).toHaveBeenCalledWith(\"[validate.js] Msg\");\n    });\n  });\n\n  describe(\"error\", function() {\n    var console = window.console;\n\n    beforeEach(function() { window.console = undefined; });\n    afterEach(function() { window.console = console; });\n\n    it(\"does nothing if the console isn't defined\", function() {\n      validate.error(\"Msg\");\n      expect(function() { validate.error(\"Msg\"); }).not.toThrow();\n    });\n\n    it(\"calls console.error if defined\", function() {\n      window.console = {\n        error: jasmine.createSpy(\"error\")\n      };\n      validate.error(\"Msg\");\n      expect(window.console.error).toHaveBeenCalledWith(\"[validate.js] Msg\");\n    });\n  });\n\n  describe(\"getDeepObjectValue\", function() {\n    it(\"supports multiple keys separated using a period\", function() {\n      var attributes = {\n        foo: {\n          bar: {\n            baz: 3\n          }\n        }\n      };\n\n      expect(validate.getDeepObjectValue(attributes, \"foo.bar.baz\")).toBe(3);\n    });\n\n    it(\"returns undefined if any key is not found\", function() {\n      var attributes = {\n        foo: {\n          bar: {\n            baz: 3\n          }\n        }\n      };\n\n      expect(validate.getDeepObjectValue(attributes, \"bar.foo\")).toBe(undefined);\n      expect(validate.getDeepObjectValue(attributes, \"foo.baz\")).toBe(undefined);\n    });\n\n    it(\"handles the object being non objects\", function() {\n      expect(validate.getDeepObjectValue(null, \"foo\")).toBe(undefined);\n      expect(validate.getDeepObjectValue(\"foo\", \"foo\")).toBe(undefined);\n      expect(validate.getDeepObjectValue(3, \"foo\")).toBe(undefined);\n      expect(validate.getDeepObjectValue([], \"foo\")).toBe(undefined);\n      expect(validate.getDeepObjectValue(true, \"foo\")).toBe(undefined);\n    });\n\n    it(\"handles the keypath being non strings\", function() {\n      expect(validate.getDeepObjectValue({}, null)).toBe(undefined);\n      expect(validate.getDeepObjectValue({}, 3)).toBe(undefined);\n      expect(validate.getDeepObjectValue({}, {})).toBe(undefined);\n      expect(validate.getDeepObjectValue({}, [])).toBe(undefined);\n      expect(validate.getDeepObjectValue({}, true)).toBe(undefined);\n    });\n\n    it(\"handles escapes properly\", function() {\n      var attributes = {\n        \"foo.bar\": {\n          baz: 3\n        },\n        \"foo\\\\\": {\n          bar: {\n            baz: 5\n          }\n        }\n      };\n\n      expect(validate.getDeepObjectValue(attributes, \"foo.bar.baz\"))\n        .toBe(undefined);\n\n      expect(validate.getDeepObjectValue(attributes, \"foo\\\\.bar.baz\"))\n        .toBe(3);\n\n      expect(validate.getDeepObjectValue(attributes, \"foo\\\\\\\\.bar.baz\"))\n        .toBe(5);\n\n      expect(validate.getDeepObjectValue(attributes, \"\\\\foo\\\\\\\\.bar.baz\"))\n        .toBe(5);\n    });\n  });\n\n  describe(\"isDate\", function() {\n    it(\"returns true for dates\", function() {\n      expect(validate.isDate(new Date())).toBe(true);\n    });\n\n    it(\"returns false for non dates\", function() {\n      expect(validate.isDate(Date.now())).toBe(false);\n      expect(validate.isDate({})).toBe(false);\n    });\n  });\n\n  describe(\"isEmpty\", function() {\n    it(\"considers null and undefined values empty\", function() {\n      expect(validate.isEmpty(null)).toBe(true);\n      expect(validate.isEmpty(undefined)).toBe(true);\n    });\n\n    it(\"considers functions non empty\", function() {\n      expect(validate.isEmpty(function(){})).toBe(false);\n    });\n\n    it(\"considers whitespace only strings empty\", function() {\n      expect(validate.isEmpty(\"\")).toBe(true);\n      expect(validate.isEmpty(\" \")).toBe(true);\n      expect(validate.isEmpty(\"         \")).toBe(true);\n      expect(validate.isEmpty(\"foo\")).toBe(false);\n    });\n\n    it(\"considers empty arrays empty\", function() {\n      expect(validate.isEmpty([])).toBe(true);\n      expect(validate.isEmpty([1])).toBe(false);\n    });\n\n    it(\"considers empty objects empty\", function() {\n      expect(validate.isEmpty({})).toBe(true);\n      expect(validate.isEmpty({foo: \"bar\"})).toBe(false);\n    });\n\n    it(\"considers false and 0 non empty\", function() {\n      expect(validate.isEmpty(false)).toBe(false);\n      expect(validate.isEmpty(0)).toBe(false);\n    });\n\n    it(\"considers date non empty\", function() {\n      spyOn(validate, \"isDate\").and.callThrough();\n      expect(validate.isEmpty(new Date())).toBe(false);\n      expect(validate.isDate).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"collectFormValues\", function() {\n    it(\"handles empty input\", function() {\n      expect(validate.collectFormValues()).toEqual({});\n    });\n\n    it(\"handles simple forms\", function() {\n      var form = document.createElement(\"form\");\n      form.innerHTML = '' +\n        '<input type=\"text\" name=\"text\" value=\"example text\">' +\n        '<input type=\"text\" name=\"empty-text\">' +\n        '<input type=\"email\" name=\"email\" value=\"example@email.com\">' +\n        '<input type=\"password\" name=\"password\" value=\"password!\">' +\n        '<input type=\"checkbox\" name=\"selected-checkbox\" value=\"checkbox\" checked>' +\n        '<input type=\"checkbox\" name=\"deselected-checkbox\" value=\"checkbox\">' +\n        '<input type=\"date\" name=\"date\" value=\"2015-03-08\">' +\n        '<input type=\"hidden\" name=\"hidden\" value=\"hidden\">' +\n        '<input type=\"number\" name=\"number\" value=\"4711\">' +\n        '<input type=\"url\" name=\"url\" value=\"http://validatejs.org\">' +\n        '<input type=\"radio\" name=\"single-checked-radio\" value=\"radio\" checked>' +\n        '<input type=\"radio\" name=\"single-unchecked-radio\" value=\"radio\">' +\n        '<radiogroup>' +\n        '  <input type=\"radio\" name=\"checked-radio\" value=\"radio1\">' +\n        '  <input type=\"radio\" name=\"checked-radio\" value=\"radio2\" checked>' +\n        '  <input type=\"radio\" name=\"checked-radio\" value=\"radio3\">' +\n        '</radiogroup>' +\n        '<radiogroup>' +\n        '  <input type=\"radio\" name=\"unchecked-radio\" value=\"radio1\">' +\n        '  <input type=\"radio\" name=\"unchecked-radio\" value=\"radio2\">' +\n        '  <input type=\"radio\" name=\"unchecked-radio\" value=\"radio3\">' +\n        '</radiogroup>' +\n        '<select name=\"selected-dropdown\">' +\n        '  <option>' +\n        '  <option value=\"option1\">' +\n        '  <option value=\"option2\" selected>' +\n        '</select>' +\n        '<select name=\"unselected-dropdown\">' +\n        '  <option>' +\n        '  <option value=\"option1\">' +\n        '  <option value=\"option2\">' +\n        '</select>' +\n        '<textarea name=\"textarea-ignored\" data-ignored>the textarea</textarea>'+\n        '<textarea name=\"textarea\">the textarea</textarea>';\n\n      expect(validate.collectFormValues(form)).toEqual({\n        text: \"example text\",\n        \"empty-text\": null,\n        email: \"example@email.com\",\n        password: \"password!\",\n        \"selected-checkbox\": \"checkbox\",\n        \"deselected-checkbox\": null,\n        date: \"2015-03-08\",\n        hidden: \"hidden\",\n        number: 4711,\n        url: \"http://validatejs.org\",\n        \"single-checked-radio\": \"radio\",\n        \"single-unchecked-radio\": null,\n        \"checked-radio\": \"radio2\",\n        \"unchecked-radio\": null,\n        \"selected-dropdown\": \"option2\",\n        \"unselected-dropdown\": null,\n        \"textarea\": \"the textarea\"\n        });\n    });\n\n    it(\"has an option to nullify empty and trim strings\", function() {\n      var form = document.createElement(\"form\");\n      form.innerHTML = '' +\n        '<input type=\"text\" name=\"normal\" value=\"normal\">' +\n        '<input type=\"text\" name=\"empty\">' +\n        '<input type=\"text\" name=\"whitespace\" value=\" \">' +\n        '<input type=\"text\" name=\"trimmed\" value=\" foo \">';\n\n      var options = {nullify: false};\n      expect(validate.collectFormValues(form, options)).toEqual({\n        normal: \"normal\",\n        empty: \"\",\n        whitespace: \" \",\n        trimmed: \" foo \"\n      });\n\n      options = {nullify: true};\n      expect(validate.collectFormValues(form, options)).toEqual({\n        normal: \"normal\",\n        empty: null,\n        whitespace: \" \",\n        trimmed: \" foo \"\n      });\n\n      options = {trim: true};\n      expect(validate.collectFormValues(form, options)).toEqual({\n        normal: \"normal\",\n        empty: null,\n        whitespace: null,\n        trimmed: \"foo\"\n      });\n    });\n\n    it(\"has a way to ignore elements\", function() {\n      var form = document.createElement(\"form\");\n      form.innerHTML = '<input type=\"text\" name=\"ignored\" value=\"ignored\" data-ignored>';\n      expect(validate.collectFormValues(form)).toEqual({});\n    });\n\n    it(\"uses true/false for checkboxes without a value\", function() {\n      var form = document.createElement(\"form\");\n      form.innerHTML = '' +\n        '<input type=\"checkbox\" name=\"checked\" checked>' +\n        '<input type=\"checkbox\" name=\"unchecked\">';\n\n      expect(validate.collectFormValues(form)).toEqual({\n        checked: true,\n        unchecked: false\n      });\n    });\n\n    it(\"accepts jquery elements\", function() {\n      var $form = $('<form><input value=\"foobar\" name=\"input\" /></form>');\n      expect(validate.collectFormValues($form)).toEqual({\n        input: \"foobar\"\n      });\n    });\n\n    it(\"empty jquery collections return empty objects\", function() {\n      expect(validate.collectFormValues($())).toEqual({});\n    });\n\n    it(\"handles empty and invalid numeric inputs\", function() {\n      var form = document.createElement(\"form\");\n      form.innerHTML = '' +\n        '<input type=\"number\" name=\"emptyNumber\">' +\n        '<input type=\"number\" name=\"invalidNumber\" value=\"abc\">';\n\n      expect(validate.collectFormValues(form)).toEqual({\n        emptyNumber: null,\n        invalidNumber: null\n      });\n    });\n\n    it(\"handles select tags with 'multiple'\", function() {\n      var form = document.createElement(\"form\");\n      form.innerHTML = '' +\n        '<select name=\"selected-dropdown\" multiple>' +\n        '  <option>' +\n        '  <option value=\"option1\">' +\n        '  <option value=\"option2\" selected>' +\n        '  <option value=\"option3\">' +\n        '  <option value=\"option4\" selected>' +\n        '</select>' +\n        '<select name=\"unselected-dropdown\" multiple>' +\n        '  <option>' +\n        '  <option value=\"option1\">' +\n        '  <option value=\"option2\">' +\n        '  <option value=\"option3\">' +\n        '  <option value=\"option4\">' +\n        '</select>' +\n        '<select name=\"empty-value\" multiple>' +\n        '  <option selected>' +\n        '</select>';\n\n      expect(validate.collectFormValues(form)).toEqual({\n        \"selected-dropdown\": [\"option2\", \"option4\"],\n        \"unselected-dropdown\": [],\n        \"empty-value\": [null]\n      });\n    });\n  });\n\n  describe(\"isDomElement\", function() {\n    it(\"returns true of DOM elements\", function() {\n      var form = document.createElement(\"form\")\n        , div = document.createElement(\"div\")\n        , a = document.createElement(\"a\");\n\n      expect(validate.isDomElement(form)).toBe(true);\n      expect(validate.isDomElement(div)).toBe(true);\n      expect(validate.isDomElement(a)).toBe(true);\n      expect(validate.isDomElement(document)).toBe(true);\n    });\n\n    it(\"returns false for other objects\", function() {\n      expect(validate.isDomElement({})).toBe(false);\n      expect(validate.isDomElement(0)).toBe(false);\n      expect(validate.isDomElement(true)).toBe(false);\n      expect(validate.isDomElement(\"foo\")).toBe(false);\n      expect(validate.isDomElement(\"\")).toBe(false);\n      expect(validate.isDomElement([])).toBe(false);\n    });\n  });\n\n  describe(\"cleanAttributes\", function() {\n    it(\"handles null for both inputs\", function() {\n      expect(validate.cleanAttributes(null, {})).toEqual({});\n      expect(validate.cleanAttributes({}, null)).toEqual({});\n      expect(validate.cleanAttributes(null, null)).toEqual({});\n    });\n\n    it(\"always returns a copy\", function() {\n      var obj = {};\n      expect(validate.cleanAttributes(obj, {})).not.toBe(obj);\n    });\n\n    it(\"returns a copy of the attributes with only the whitelisted attributes\", function() {\n      var input = {\n        foo: \"foo\",\n        bar: \"bar\",\n        baz: \"baz\"\n      };\n\n      expect(validate.cleanAttributes(input, {})).toEqual({});\n      expect(validate.cleanAttributes(input, {foo: true})).toEqual({\n        foo: \"foo\"\n      });\n      expect(validate.cleanAttributes(input, {foo: true, bar: true})).toEqual({\n        foo: \"foo\",\n        bar: \"bar\"\n      });\n      expect(validate.cleanAttributes(input, {foo: true, bar: true, baz: true})).toEqual({\n        foo: \"foo\",\n        bar: \"bar\",\n        baz: \"baz\"\n      });\n      expect(validate.cleanAttributes(input, {foo: false})).toEqual({});\n    });\n\n    it(\"handles nested objects\", function() {\n      var attributes = {\n        \"foo.bar.baz\": \"foobarbaz\",\n        foo: {\n          shouldBeRemoved: \"yup\",\n          bar: {\n            shouldAlsoBeRemoved: \"uhuh\",\n            baz: \"baz\",\n            quux: \"quux\"\n          }\n        },\n        one: {\n          two: {\n            four: \"shouldBeRemoved\"\n          }\n        },\n        somethingThatIsNull: null\n      };\n\n      var whitelist = {\n        \"foo\\\\.bar\\\\.baz\": true,\n        \"foo.bar.baz\": true,\n        \"foo.bar.quux\": true,\n        \"one.two.three\": true,\n        \"somethingThatIsNull.someSubThingie\": true\n      };\n      expect(validate.cleanAttributes(attributes, whitelist)).toEqual({\n        \"foo.bar.baz\": \"foobarbaz\",\n        foo: {\n          bar: {\n            baz: \"baz\",\n            quux: \"quux\"\n          }\n        },\n        one: {\n          two: {\n          }\n        },\n        somethingThatIsNull: null\n      });\n    });\n\n    it(\"works with constraints\", function() {\n      var attributes = {\n        name: \"Test\",\n        description: \"Yaay\",\n        createdAt: 'omgomg',\n        address: {\n          street: \"Some street\",\n          postal: \"47 111\"\n        }\n      };\n\n      var constraints = {\n        name: {\n          presence: true\n        },\n        description: {},\n        \"address.street\": {},\n        \"address.postal\": {},\n        \"address.country\": {}\n      };\n\n      expect(validate.cleanAttributes(attributes, constraints)).not.toBe(attributes);\n      expect(validate.cleanAttributes(attributes, constraints)).toEqual({\n        name: \"Test\",\n        description: \"Yaay\",\n        address: {\n          street: \"Some street\",\n          postal: \"47 111\"\n        }\n      });\n    });\n  });\n\n  describe(\"unique\", function() {\n    it(\"handles empty and single value arrays\", function() {\n      expect(validate.unique(null)).toEqual(null);\n      expect(validate.unique([])).toEqual([]);\n      expect(validate.unique([1])).toEqual([1]);\n      expect(validate.unique([\"foo\"])).toEqual([\"foo\"]);\n      expect(validate.unique(\"foo\")).toEqual(\"foo\");\n    });\n\n    it(\"filters non unique values\", function() {\n      expect(validate.unique([\"foo\", \"bar\", \"bar\", \"foo\", \"baz\"]))\n        .toEqual([\"foo\", \"bar\", \"baz\"]);\n\n      expect(validate.unique([\"foo\", \"foo\", \"foo\"]))\n        .toEqual([\"foo\"]);\n\n      expect(validate.unique([1, 2, 3, 3, 2, 1]))\n        .toEqual([1, 2, 3]);\n    });\n\n    it(\"returns a copy\", function() {\n      var a = [\"foo\"];\n      expect(validate.unique(a)).not.toBe(a);\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validate-spec.js":"describe(\"validate\", function() {\n  var validators = validate.validators\n    , fail\n    , fail2\n    , pass\n    , pass2;\n\n  beforeEach(function() {\n    fail = jasmine.createSpy('failValidator').and.returnValue(\"my error\");\n    fail2 = jasmine.createSpy('failValidator2').and.returnValue(\"my error\");\n    pass = jasmine.createSpy('passValidator');\n    pass2 = jasmine.createSpy('passValidator2');\n    validators.pass = pass;\n    validators.pass2 = pass2;\n    validators.fail = fail;\n    validators.fail2 = fail2;\n  });\n\n  afterEach(function() {\n    delete validators.fail;\n    delete validators.fail2;\n    delete validators.pass;\n    delete validators.pass2;\n    delete validate.options;\n  });\n\n  it(\"raises an error if a promise is returned\", function() {\n    fail.and.returnValue(new validate.Promise(function() {}));\n    var constraints = {name: {fail: true}};\n    expect(function() { validate({}, constraints); }).toThrow();\n  });\n\n  it(\"runs as expected\", function() {\n    var attributes = {\n      name: \"Nicklas Ansman\",\n      email: \"nicklas@ansman.se\",\n      addresses: {\n        work: {\n          street: \"Drottninggatan 98\",\n          city: \"Stockholm\"\n        }\n      }\n    };\n    var constraints = {\n      name: {\n        pass: true\n      },\n      email: {\n        pass: true,\n        fail: true,\n        fail2: true\n      },\n      \"addresses.work.street\": {\n        pass: true,\n        fail2: true,\n      },\n      \"addresses.work.city\": {\n        pass: true\n      },\n    };\n\n    fail.and.returnValue(\"must be a valid email address\");\n    fail2.and.returnValue(\"is simply not good enough\");\n\n    expect(validate(attributes, constraints)).toEqual({\n      email: [\n        \"Email must be a valid email address\",\n        \"Email is simply not good enough\"\n      ],\n      \"addresses.work.street\": [\n        \"Addresses work street is simply not good enough\"\n      ]\n    });\n\n    expect(validate(attributes, constraints, {format: \"flat\"})).toEqual([\n      \"Email must be a valid email address\",\n      \"Email is simply not good enough\",\n      \"Addresses work street is simply not good enough\"\n    ]);\n  });\n\n  it(\"works with nested objects set to null\", function() {\n    var constraints = {\n      \"foo.bar\": {\n        presence: true\n      }\n    };\n    expect(validate({foo: null}, constraints)).toBeDefined();\n  });\n\n  describe(\"runValidations\", function() {\n    it(\"throws an error when the validator is not found\", function() {\n      expect(function() {\n        validate.runValidations({}, {name: {foobar: true}}, {});\n      }).toThrow(new Error(\"Unknown validator foobar\"));\n    });\n\n    it(\"calls the validator with the validator itself as context\", function() {\n      validate.runValidations({}, {name: {pass: true}}, {});\n      expect(pass).toHaveBeenCalledWithContext(pass);\n    });\n\n    it(\"calls the validator with the val, opts, key, attributes and global options\", function() {\n      var options = {someOption: true}\n        , attributes = {someAttribute: 'some value'}\n        , constraints = {someAttribute: {pass: options}}\n        , globalOptions = {someOption: 'some value'};\n      validate.runValidations(attributes, constraints, globalOptions);\n      expect(pass).toHaveBeenCalledWith('some value',\n                                        options,\n                                        'someAttribute',\n                                        attributes,\n                                        globalOptions);\n    });\n\n    it(\"returns an array of results\", function() {\n      fail.and.returnValue(\"foobar\");\n      fail2.and.returnValue([\"foo\", \"bar\"]);\n      pass.and.returnValue(null);\n\n      var options = {someOption: true}\n        , globalOptions = {globalOption: \"globalValue\"}\n        , constraints = {name: {fail: options, fail2: true, pass: true}}\n        , attributes = {name: \"test\"};\n      var result = validate.runValidations(attributes, constraints, globalOptions);\n\n      expect(result).toHaveItems([{\n        attribute: \"name\",\n        value: \"test\",\n        validator: \"fail\",\n        options: options,\n        attributes: attributes,\n        globalOptions: globalOptions,\n        error: \"foobar\"\n      }, {\n        attribute: \"name\",\n        value: \"test\",\n        validator: \"fail2\",\n        options: true,\n        attributes: attributes,\n        globalOptions: globalOptions,\n        error: [\"foo\", \"bar\"]\n      }, {\n        attribute: \"name\",\n        value: \"test\",\n        validator: \"pass\",\n        options: true,\n        attributes: attributes,\n        globalOptions: globalOptions,\n        error: null\n      }]);\n    });\n\n    it(\"validates all attributes\", function() {\n      fail.and.returnValue(\"error\");\n      var constraints = {\n        attr1: {pass: {foo: \"bar\"}},\n        attr2: {fail: true},\n        attr3: {fail: true}\n      };\n      expect(validate.runValidations({}, constraints, {})).toHaveItems([\n        {\n          attribute: \"attr1\",\n          value: undefined,\n          validator: \"pass\",\n          options: {foo: \"bar\"},\n          attributes: {},\n          globalOptions: {},\n          error: undefined\n        }, {\n          attribute: \"attr2\",\n          value: undefined,\n          validator: \"fail\",\n          options: true,\n          attributes: {},\n          globalOptions: {},\n          error: \"error\"\n        }, {\n          attribute: \"attr3\",\n          value: undefined,\n          validator: \"fail\",\n          options: true,\n          attributes: {},\n          globalOptions: {},\n          error: \"error\"\n        }\n      ]);\n    });\n\n    it(\"allows the options for an attribute to be a function\", function() {\n      var options = {pass: {option1: \"value1\"}}\n        , attrs = {name: \"Nicklas\"}\n        , spy = jasmine.createSpy(\"options\").and.returnValue(options)\n        , constraints = {name: spy}\n        , globalOptions = {foo: \"bar\"};\n      validate.runValidations(attrs, constraints, globalOptions);\n      expect(spy).toHaveBeenCalledWith(\"Nicklas\", attrs, \"name\", globalOptions, constraints);\n      expect(pass).toHaveBeenCalledWith(\"Nicklas\", options.pass, \"name\", attrs, globalOptions);\n    });\n\n    it(\"allows the options for a validator to be a function\", function() {\n      var options = {option1: \"value1\"}\n        , attrs = {name: \"Nicklas\"}\n        , spy = jasmine.createSpy(\"options\").and.returnValue(options)\n        , constraints = {name: {pass: spy}}\n        , globalOptions = {foo: \"bar\"};\n      validate.runValidations(attrs, constraints, globalOptions);\n      expect(spy).toHaveBeenCalledWith(\"Nicklas\", attrs, \"name\", globalOptions, constraints);\n      expect(pass).toHaveBeenCalledWith(\"Nicklas\", options, \"name\", attrs, globalOptions);\n    });\n\n    it(\"doesnt run the validations if the options are falsy\", function() {\n      validate.runValidations({}, {name: {pass: false}, email: {pass: null}}, {});\n      expect(pass).not.toHaveBeenCalled();\n    });\n\n    it(\"calls collectFormValues if the attributes is a DOM or jQuery element\", function() {\n      var form = document.createElement(\"div\")\n        , $form = $(form);\n      form.innerHTML = '<input type=\"text\" name=\"foo\" value=\"bar\">';\n      spyOn(validate, \"collectFormValues\").and.callThrough();\n      spyOn(validate.validators, \"presence\").and.callThrough();\n      var constraints = {foo: {presence: true}};\n\n      validate(form, constraints);\n\n      expect(validate.collectFormValues).toHaveBeenCalledWith(form);\n      expect(validate.validators.presence).toHaveBeenCalledWith(\n        \"bar\",\n        true,\n        \"foo\",\n        {foo: \"bar\"},\n        {}\n      );\n\n      validate($form, constraints);\n      expect(validate.collectFormValues).toHaveBeenCalledWith($form);\n      expect(validate.validators.presence).toHaveBeenCalledWith(\n        \"bar\",\n        true,\n        \"foo\",\n        {foo: \"bar\"},\n        {}\n      );\n    });\n  });\n\n  describe(\"format\", function() {\n    describe(\"flat\", function() {\n      it(\"returns a flat list of errors\", function() {\n        var c = {\n          foo: {\n            presence: true,\n            numericality: true,\n            length: {\n              is: 23,\n              wrongLength: \"some error\"\n            }\n          }\n        };\n        expect(validate({foo: \"bar\"}, c, {format: \"flat\"})).toHaveItems([\n          \"Foo some error\",\n          \"Foo is not a number\"\n        ]);\n      });\n\n      it(\"fullMessages = false\", function() {\n        var constraints = {foo: {presence: true}}\n          , options = {format: \"flat\", fullMessages: false};\n        expect(validate({}, constraints, options)).toEqual([\"can't be blank\"]);\n      });\n\n      it(\"deduplicates errors\", function() {\n        var c = {\n          foo: {\n            numericality: {\n              message: \"some error\"\n            },\n            length: {\n              is: 23,\n              wrongLength: \"some error\"\n            }\n          }\n        };\n        expect(validate({foo: \"bar\"}, c, {format: \"flat\"})).toHaveItems([\n          \"Foo some error\"\n        ]);\n      });\n    });\n\n    describe(\"grouped\", function() {\n      it(\"deduplicates errors\", function() {\n        var c = {\n          foo: {\n            numericality: {\n              message: \"some error\"\n            },\n            length: {\n              is: 23,\n              wrongLength: \"some error\"\n            }\n          }\n        };\n        expect(validate({foo: \"bar\"}, c)).toEqual({\n          foo: [\"Foo some error\"]\n        });\n      });\n    });\n\n    describe(\"detailedErrors\", function() {\n      it(\"allows you to get more info about the errors\", function() {\n        var attributes = {\n          foo: \"foo\",\n          bar: 10\n        };\n        var c = {\n          foo: {\n            presence: true,\n            length: {\n              is: 15,\n              message: \"^foobar\",\n              someOption: \"someValue\"\n            }\n          },\n          bar: {\n            numericality: {\n              lessThan: 5,\n              greaterThan: 15\n            }\n          }\n        };\n        var options = {format: \"detailed\"};\n        expect(validate(attributes, c, options)).toHaveItems([{\n            attribute: \"foo\",\n            value: \"foo\",\n            validator: \"length\",\n            options: {\n              is: 15,\n              message: \"^foobar\",\n              someOption: \"someValue\"\n            },\n            attributes: attributes,\n            globalOptions: options,\n            error: \"foobar\"\n          }, {\n            attribute: \"bar\",\n            value: 10,\n            validator: \"numericality\",\n            options: {\n              lessThan: 5,\n              greaterThan: 15\n            },\n            attributes: attributes,\n            globalOptions: options,\n            error: \"Bar must be greater than 15\"\n          }, {\n            attribute: \"bar\",\n            value: 10,\n            validator: \"numericality\",\n            options: {\n              lessThan: 5,\n              greaterThan: 15\n            },\n            attributes: attributes,\n            globalOptions: options,\n            error: \"Bar must be less than 5\"\n        }]);\n      });\n    });\n    describe(\"constraint\", function() {\n      it(\"returns constraint names\", function() {\n        var c = {\n          foo: {\n            numericality: true,\n            length: {\n              is: 23\n            }\n          }\n        };\n        expect(validate({foo: \"bar\"}, c, { format: 'constraint' })).toEqual({\n          foo: [\"length\", \"numericality\"]\n        });\n      });\n      it(\"sorts constraint names\", function() {\n        var c = {\n          foo: {\n            numericality: true,\n            length: {\n              is: 23\n            }\n          }\n        };\n        expect(validate({foo: \"bar\"}, c, { format: 'constraint' })).toEqual({\n          foo: [\"length\", \"numericality\"]\n        });\n      });\n    });\n  });\n\n  it(\"allows validators to return functions as messages\", function() {\n    var message = jasmine.createSpy(\"message\").and.returnValue(\"some message\")\n      , validatorOptions = {validatorOption: \"validatorValue\"}\n      , options = {option: \"value\"}\n      , constraints = { foo: { fail: validatorOptions } }\n      , attributes = {foo: \"bar\"};\n    fail.and.returnValue(message);\n    expect(validate(attributes, constraints, options)).toEqual({\n      foo: [\"Foo some message\"]\n    });\n    expect(message).toHaveBeenCalledWith(\n        \"bar\",\n        \"foo\",\n        validatorOptions,\n        attributes,\n        options);\n  });\n\n  it(\"allows validators to return objects as messages\", function() {\n    var message = {foo: \"bar\"};\n    fail.and.returnValue(message);\n    expect(validate({}, {foo: {fail: true}})).toEqual({\n      foo: [message]\n    });\n  });\n\n  it(\"allows default options\", function() {\n    var constraints = {foo: {presence: true}}\n      , options = {foo: \"bar\"};\n    validate.options = {format: \"flat\"};\n    expect(validate({}, constraints, options)).toEqual([\"Foo can't be blank\"]);\n    expect(options).toEqual({foo: \"bar\"});\n    expect(validate.options).toEqual({format: \"flat\"});\n  });\n\n  describe(\"single\", function() {\n    it(\"validates the single property\", function() {\n      var validators = {\n        presence: {\n          message: \"example message\"\n        },\n        length: {\n          is: 6,\n          message: \"^It needs to be 6 characters long\"\n        }\n      };\n\n      expect(validate.single(null, validators)).toEqual([\"example message\"]);\n      expect(validate.single(\"foo\", validators)).toEqual([\"It needs to be 6 characters long\"]);\n      expect(validate.single(\"foobar\", validators)).not.toBeDefined();\n    });\n\n    it(\"doesn't support the format and fullMessages options\", function() {\n      var validators = {presence: true}\n        , options = {format: \"detailed\", fullMessages: true};\n\n      expect(validate.single(null, validators, options))\n        .toEqual([\"can't be blank\"]);\n    });\n  });\n\n  describe(\"version\", function() {\n    var metadata = validate.version.metadata;\n\n    beforeEach(function() {\n      validate.version.metadata = null;\n    });\n\n    afterEach(function() {\n      validate.version.metadata = metadata;\n    });\n\n    it(\"contains major, minor and patch version\", function() {\n      expect(validate.version.major).toBeANumber();\n      expect(validate.version.minor).toBeANumber();\n      expect(validate.version.patch).toBeANumber();\n    });\n\n    it(\"can be converted to a string\", function() {\n      var version = validate.version.major + \".\" +\n        validate.version.minor + \".\" +\n        validate.version.patch;\n\n      expect(\"\" + validate.version).toEqual(version);\n    });\n\n    it(\"the string version can have metadata\", function() {\n      var version = validate.version.major + \".\" +\n        validate.version.minor + \".\" +\n        validate.version.patch + \"+foobar\";\n\n      validate.version.metadata = \"foobar\";\n\n      expect(\"\" + validate.version).toEqual(version);\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/datetime-spec.js":"describe('validators.datetime', function() {\n  var datetime = validate.validators.datetime.bind(validate.validators.datetime)\n    , parse = validate.validators.datetime.parse\n    , format = validate.validators.datetime.format;\n\n  beforeEach(function() {\n    validate.validators.datetime.parse = function(value) {\n      return +moment.utc(value);\n    };\n    validate.validators.datetime.format = function(value, options) {\n      var format = \"YYYY-MM-DD\";\n      if (!options.dateOnly) {\n        format += \" HH:mm:ss\";\n      }\n      return moment.utc(value).format(format);\n    };\n  });\n\n  afterEach(function() {\n    delete validate.validators.datetime.notValid;\n    delete validate.validators.datetime.tooEarly;\n    delete validate.validators.datetime.tooLate;\n    delete validate.validators.datetime.options;\n    validate.validators.datetime.parse = parse;\n    validate.validators.datetime.format = parse;\n  });\n\n  it(\"throws an exception if format and parse isn't set\", function() {\n    var p = validate.validators.datetime.parse\n      , f = validate.validators.datetime.format;\n    validate.validators.datetime.parse = parse;\n    validate.validators.datetime.format = format;\n\n    expect(function() { datetime(null, {}); }).toThrow();\n\n    validate.validators.datetime.parse = p;\n    expect(function() { datetime(null, {}); }).toThrow();\n\n    validate.validators.datetime.parse = parse;\n    validate.validators.datetime.format = f;\n    expect(function() { datetime(null, {}); }).toThrow();\n\n    validate.validators.datetime.parse = p;\n    expect(function() { datetime(null, {}); }).not.toThrow();\n  });\n\n  it(\"allows undefined values\", function() {\n    spyOn(validate.validators.datetime, \"parse\");\n    spyOn(validate.validators.datetime, \"format\");\n    expect(datetime(null, {})).not.toBeDefined();\n    expect(datetime(undefined, {})).not.toBeDefined();\n    expect(validate.validators.datetime.parse).not.toHaveBeenCalled();\n    expect(validate.validators.datetime.format).not.toHaveBeenCalled();\n  });\n\n  it(\"allows valid dates\", function() {\n    expect(datetime(\"2013-10-26 13:47:00\", {})).not.toBeDefined();\n  });\n\n  it(\"doesn't allow invalid dates\", function() {\n    var expected = \"must be a valid date\";\n    expect(datetime(\"foobar\", {})).toEqual(expected);\n    expect(datetime(\"\", {})).toEqual(expected);\n    expect(datetime(\"  \", {})).toEqual(expected);\n  });\n\n  it(\"doesn't allow h, m or s when dateOnly is true\", function() {\n    var expected = \"must be a valid date\"\n      , opts = {dateOnly: true};\n\n    expect(datetime(\"2013-10-26 13:47:00\", opts)).toEqual(expected);\n    expect(datetime(\"2013-10-26\", opts)).not.toBeDefined();\n  });\n\n  it(\"returns the message if specified for invalid dates\", function() {\n    validate.validators.datetime.notValid = \"notValid\";\n    expect(datetime(\"foobar\", {})).toEqual(\"notValid\");\n\n    var opts = {message: \"my other message\"};\n    expect(datetime(\"foobar\", opts)).toEqual(\"my other message\");\n  });\n\n  it(\"allows tooLate, tooEarly and notValid messages\", function() {\n    var options = {\n      tooLate: \"%{value} is later than %{date}\",\n      tooEarly: \"%{value} is earlier than %{date}\",\n      notValid: \"%{value} is not valid\",\n      message: \"fail\",\n      earliest: \"2015-01-01\",\n      latest: \"2015-12-31\",\n      dateOnly: true\n    };\n    expect(datetime(\"foobar\", options)).toEqual(\"foobar is not valid\");\n    expect(datetime(\"2014-01-01\", options))\n      .toEqual([\"2014-01-01 is earlier than 2015-01-01\"]);\n    expect(datetime(\"2016-01-01\", options))\n      .toEqual([\"2016-01-01 is later than 2015-12-31\"]);\n  });\n\n  it(\"message overrides global messages\", function() {\n    var options = {\n      message: \"some message\",\n      earliest: \"2016-01-01\",\n      latest: \"2015-12-30\",\n      dateOnly: true\n    };\n    validate.validators.datetime.notValid = \"notValid\";\n    validate.validators.datetime.tooEarly = \"tooEarly\";\n    validate.validators.datetime.tooLate = \"tooLate\";\n    expect(datetime(\"foobar\", options)).toEqual(\"some message\");\n    expect(datetime(\"2015-12-31\", options)).toEqual([\"some message\"]);\n  });\n\n  describe(\"earliest\", function() {\n    it(\"doesn't allow earlier dates\", function() {\n      var options = {earliest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-25 23:59:59\"\n        , expected = [\"must be no earlier than 2013-10-26 00:00:00\"];\n\n      expect(datetime(value, options)).toEqual(expected);\n    });\n\n    it(\"allows earlier or equal dates\", function() {\n      var options = {earliest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-26 00:00:00\";\n      expect(datetime(value, options)).not.toBeDefined();\n      value = \"2013-10-27 00:00:00\";\n      expect(datetime(value, options)).not.toBeDefined();\n    });\n\n    it(\"formats the error using the format function\", function() {\n      var options = {earliest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-25 00:00:00\"\n        , spy = spyOn(validate.validators.datetime, 'format')\n          .and.returnValue(\"foobar\")\n        , expected = [\"must be no earlier than foobar\"];\n      expect(datetime(value, options)).toEqual(expected);\n    });\n\n    it(\"parses the earliest value using the parse function\", function() {\n      var options = {earliest: 'foobar'}\n        , value = moment.utc().startOf('day')\n        , spy = spyOn(validate.validators.datetime, 'parse').and.returnValue(value);\n      datetime(value, options);\n      expect(spy).toHaveBeenCalledWith('foobar', options);\n    });\n\n    it(\"uses the default message if available\", function() {\n      var options = {earliest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-25 23:59:59\";\n\n      validate.validators.datetime.tooEarly = \"default message\";\n      expect(datetime(value, options)).toEqual([\"default message\"]);\n\n      options.message = \"overridden\";\n      expect(datetime(value, options)).toEqual([\"overridden\"]);\n    });\n  });\n\n  describe(\"latest\", function() {\n    it(\"doesn't allow later dates\", function() {\n      var options = {latest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-26 00:00:01\"\n        , expected = [\"must be no later than 2013-10-26 00:00:00\"];\n\n      expect(datetime(value, options)).toEqual(expected);\n    });\n\n    it(\"allows later or equal dates\", function() {\n      var options = {latest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-26 00:00:00\";\n      expect(datetime(value, options)).not.toBeDefined();\n      value = \"2013-10-25 00:00:00\";\n      expect(datetime(value, options)).not.toBeDefined();\n    });\n\n    it(\"formats the error using the format function\", function() {\n      var options = {latest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-27 00:00:00\"\n        , spy = spyOn(validate.validators.datetime, 'format').and.returnValue(\"foobar\")\n        , expected = [\"must be no later than foobar\"];\n      expect(datetime(value, options)).toEqual(expected);\n    });\n\n    it(\"parses the latest value using the parse function\", function() {\n      var options = {latest: 'foobar'}\n        , value = moment.utc().startOf('day')\n        , spy = spyOn(validate.validators.datetime, 'parse').and.returnValue(value);\n      datetime(value, options);\n      expect(spy).toHaveBeenCalledWith('foobar', options);\n    });\n\n    it(\"uses the default message if available\", function() {\n      var options = {latest: '2013-10-26 00:00:00'}\n        , value = \"2013-10-26 00:00:01\";\n\n      validate.validators.datetime.tooLate = \"default message\";\n      expect(datetime(value, options)).toEqual([\"default message\"]);\n\n      options.message = \"overridden\";\n      expect(datetime(value, options)).toEqual([\"overridden\"]);\n    });\n  });\n\n  it(\"can return multiple errors\", function() {\n    var options = {\n          earliest: '2013-10-26 00:00:00',\n          latest: '2013-10-24 00:00:00'\n        }\n      , value = \"2013-10-25 00:00:00\";\n    expect(datetime(value, options)).toHaveItems([\n        \"must be no later than 2013-10-24 00:00:00\",\n        \"must be no earlier than 2013-10-26 00:00:00\"\n    ]);\n  });\n\n  it(\"returns the user defined message only once\", function() {\n    var options = {\n          earliest: '2013-10-26 00:00:00',\n          latest: '2013-10-24 00:00:00',\n          message: 'foobar'\n        }\n      , value = \"2013-10-25 00:00:00\";\n    expect(datetime(value, options)).toEqual(['foobar']);\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.datetime.options =\n      {message: \"barfoo\", earliest: \"2013-10-26 00:00:00\"};\n    var options = {message: 'foobar'}\n      , value = \"2013-10-25 00:00:00\";\n    expect(datetime(value, options)).toEqual(['foobar']);\n    expect(datetime(value, {})).toEqual(['barfoo']);\n    expect(validate.validators.datetime.options)\n      .toEqual({message: \"barfoo\", earliest: \"2013-10-26 00:00:00\"});\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {\n          earliest: '2013-10-26 00:00:00',\n          latest: '2013-10-24 00:00:00',\n          message: message\n        }\n      , value = \"2013-10-25 00:00:00\";\n    expect(datetime(value, options)).toEqual([message]);\n  });\n});\n\ndescribe('validators.date', function() {\n  it(\"calls the datetime validator with dateOnly set to true\", function() {\n    var errors = [\"my error\"]\n      , value = \"my value\"\n      , options = {foo: \"bar\"}\n      , spy = spyOn(validate.validators, 'datetime').and.returnValue(errors);\n    expect(validate.validators.date(value, options)).toBe(errors);\n    expect(spy).toHaveBeenCalledWith(value, {foo: \"bar\", dateOnly: true});\n  });\n\n  it(\"doesn't modify the options argument\", function() {\n    var options = {}\n      , spy = spyOn(validate.validators, 'datetime');\n    validate.validators.date(\"value\", options);\n    expect(options).toEqual({});\n  });\n\n  it(\"calls the datetime validator with the right context\", function() {\n    spyOn(validate.validators, 'datetime');\n    validate.validators.date(\"foo\", {});\n    expect(validate.validators.datetime).toHaveBeenCalledWithContext(validate.validators.datetime);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/email-spec.js":"describe('validators.email', function() {\n  var email = validate.validators.email;\n  email = email.bind(email);\n\n  afterEach(function() {\n    delete validate.validators.email.message;\n    delete validate.validators.email.options;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(email(null, {})).not.toBeDefined();\n    expect(email(undefined, {})).not.toBeDefined();\n  });\n\n  it(\"doesn't allow non strings\", function() {\n    expect(email(3.14, {})).toBeDefined();\n    expect(email(true, {})).toBeDefined();\n  });\n\n  it(\"allows valid emails\", function() {\n    expect(email('nicklas@ansman.se', {})).not.toBeDefined();\n    expect(email('NiCkLaS@AnSmAn.Se', {})).not.toBeDefined();\n    // Source: https://en.wikipedia.org/wiki/Email_address#Valid_email_addresses\n    expect(email('niceandsimple@example.com', {})).not.toBeDefined();\n    expect(email('very.common@example.com', {})).not.toBeDefined();\n    expect(email('a.little.lengthy.but.fine@dept.example.com', {})).not.toBeDefined();\n    expect(email('disposable.style.email.with+symbol@example.com', {})).not.toBeDefined();\n    expect(email('other.email-with-dash@example.com', {})).not.toBeDefined();\n    expect(email('üñîçøðé@example.com', {})).not.toBeDefined();\n    expect(email(\"foo@some.customtld\", {})).not.toBeDefined();\n  });\n\n  it(\"doesn't allow 'invalid' emails\", function() {\n    var expected = \"is not a valid email\";\n    expect(email(\"\", {})).toEqual(expected);\n    expect(email(\" \", {})).toEqual(expected);\n    expect(email(\"foobar\", {})).toEqual(expected);\n    expect(email(\"foo@bar\", {})).toEqual(expected);\n\n    // Source: https://en.wikipedia.org/wiki/Email_address#Invalid_email_addresses\n    expect(email('abc.example.com', {})).toEqual(expected);\n    expect(email('a@b@c@example.com', {})).toEqual(expected);\n    expect(email('a\"b(c)d,e:f;g<h>i[j\\\\k]l@example.com', {})).toEqual(expected);\n    expect(email('just\"not\"right@example.com', {})).toEqual(expected);\n    expect(email('this is\"not\\\\allowed@example.com', {})).toEqual(expected);\n    expect(email('this\\\\ still\\\\\"not\\\\\\\\allowed@example.com', {})).toEqual(expected);\n  });\n\n  it(\"allows you to customize the error message\", function() {\n    validate.validators.email.message = \"is totally not an email\";\n    expect(email(\"foobar\", {})).toEqual(\"is totally not an email\");\n    var options = {message: \"some other message\"};\n    expect(email(\"foobar\", options)).toEqual(\"some other message\");\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.email.options = {message: \"barfoo\"};\n    var options = {message: 'foobar'};\n    expect(email(\"foo\", options)).toEqual('foobar');\n    expect(email(\"foo\", {})).toEqual('barfoo');\n    expect(validate.validators.email.options).toEqual({message: \"barfoo\"});\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message}\n      , value = \"foo\";\n    expect(email(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/equality-spec.js":"describe('validators.equality', function() {\n  var equality = validate.validators.equality;\n  equality = equality.bind(equality);\n\n  afterEach(function() {\n    delete validate.validators.equality.message;\n    delete validate.validators.equality.options;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(equality(null, \"bar\", \"foo\", {})).not.toBeDefined();\n    expect(equality(undefined, \"bar\", \"foo\", {})).not.toBeDefined();\n  });\n\n  it(\"supports equality with another attribute\", function() {\n    expect(equality(\"\", \"bar\", \"foo\", {foo: \"foo\"})).toBeDefined();\n    expect(equality(\"  \", \"bar\", \"foo\", {foo: \"foo\"})).toBeDefined();\n    expect(equality(\"foo\", \"bar\", \"foo\", {foo: \"foo\"})).toBeDefined();\n    expect(equality(\"foo\", \"bar\", \"foo\", {foo: \"foo\", bar: \"bar\"})).toBeDefined();\n    expect(equality(\"foo\", \"bar\", \"foo\", {foo: \"foo\", bar: \"foo\"})).not.toBeDefined();\n\n    expect(equality(1, \"bar\", \"foo\", {foo: 1})).toBeDefined();\n    expect(equality(1, \"bar\", \"foo\", {foo: 1, bar: 2})).toBeDefined();\n    expect(equality(1, \"bar\", \"foo\", {foo: 1, bar: 1})).not.toBeDefined();\n  });\n\n  it(\"has a nice default message\", function() {\n    var constraints = {\n      foo: {\n        equality: \"fooBar\"\n      }\n    };\n    expect(equality(\"foo\", \"fooBar\", \"foo\", {foo: \"foo\"})).toEqual(\"is not equal to foo bar\");\n  });\n\n  it(\"allows you to customize the error message\", function() {\n    validate.validators.equality.message = \"is totally not equal to %{attribute}\";\n    expect(equality(\"foo\", \"bar\", \"foo\", {foo: \"foo\"})).toEqual(\"is totally not equal to bar\");\n    var options = {attribute: \"bar\", message: \"some other message %{attribute}\"};\n    expect(equality(\"foo\", options, \"foo\", {foo: \"foo\"})).toEqual(\"some other message bar\");\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.equality.options = {message: \"barfoo\", attribute: \"bar\"};\n    var options = {message: 'foobar', attribute: \"baz\"};\n    expect(equality(\"foo\", options, \"foo\", {foo: \"foo\"})).toEqual('foobar');\n    expect(equality(\"foo\", {}, \"foo\", {foo: \"foo\"})).toEqual('barfoo');\n    expect(equality(\"foo\", {message: \"foobar\"}, \"foo\", {foo: \"foo\"})).toEqual('foobar');\n    expect(validate.validators.equality.options).toEqual({message: \"barfoo\", attribute: \"bar\"});\n    expect(options).toEqual({message: \"foobar\", attribute: \"baz\"});\n  });\n\n  it(\"supports nested objects\", function() {\n    expect(equality(\"foo\", \"bar.baz\", \"foo\", {foo: \"foo\"})).toBeDefined();\n    expect(equality(\"foo\", \"bar.baz\", \"foo\", {foo: \"foo\", bar: {baz: \"baz\"}})).toBeDefined();\n    expect(equality(\"foo\", \"bar.baz\", \"foo\", {foo: \"foo\", bar: {baz: \"foo\"}})).not.toBeDefined();\n  });\n\n  it(\"throws an error if the attribute option isn't provided\", function() {\n    function run(options) {\n      equality(\"foo\", options, \"foo\", {foo: \"foo\"});\n    }\n\n    expect(run.bind({})).toThrow();\n    expect(run.bind({attribute: null})).toThrow();\n    expect(run.bind({attribute: 4711})).toThrow();\n    expect(run.bind({attribute: false})).toThrow();\n    expect(run.bind({attribute: undefined})).toThrow();\n    expect(run.bind({attribute: \"\"})).toThrow();\n  });\n\n  it(\"accepts an optional comparator\", function() {\n    var complex = {foo: \"bar\"}\n      , other = {bar: \"foo\"}\n      , comparator = jasmine.createSpy(\"comparator\").and.returnValue(true)\n      , attributes = {complex: complex, other: other}\n      , constraints = {\n          complex: {\n            equality: {\n              attribute: \"other\",\n              comparator: comparator\n            }\n          }\n        };\n\n    expect(validate(attributes, constraints)).not.toBeDefined();\n    expect(comparator)\n      .toHaveBeenCalledWith(complex,\n                            other,\n                            constraints.complex.equality,\n                            \"complex\",\n                            attributes);\n\n    comparator.and.returnValue(false);\n    expect(validate(attributes, constraints)).toBeDefined();\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message, attribute: \"bar\"}\n      , value = \"foo\";\n    expect(equality(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/exclusion-spec.js":"describe(\"validators.exclusion\", function() {\n  var exclusion = validate.validators.exclusion.bind(validate.validators.exclusion)\n    , within = [\"foo\", \"bar\", \"baz\"];\n\n  afterEach(function() {\n    delete validate.validators.exclusion.message;\n    delete validate.validators.exclusion.options;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(exclusion(null, {})).not.toBeDefined();\n    expect(exclusion(undefined, {})).not.toBeDefined();\n  });\n\n  it(\"returns nothing if the value is allowed\", function() {\n    var opts = {within: within};\n    expect(exclusion(\"\", {})).not.toBeDefined();\n    expect(exclusion(\" \", {})).not.toBeDefined();\n    expect(exclusion(\"quux\", opts)).not.toBeDefined();\n    expect(exclusion(false, opts)).not.toBeDefined();\n    expect(exclusion(1, opts)).not.toBeDefined();\n  });\n\n  it(\"returns an error if the value is not allowed\", function() {\n    var opts = {within: within};\n    expect(exclusion(\"foo\", opts)).toEqual(\"^foo is restricted\");\n    expect(exclusion(\"bar\", opts)).toEqual(\"^bar is restricted\");\n    expect(exclusion(\"baz\", opts)).toEqual(\"^baz is restricted\");\n  });\n\n  it(\"allows you to customize the message\", function() {\n    validate.validators.exclusion.message = \"^%{value} isn't great\";\n    var opts = {within: within};\n    expect(exclusion(\"foo\", opts)).toEqual(\"^foo isn't great\");\n\n    opts.message = \"^The value %{value} is not valid\";\n    expect(exclusion(\"foo\", opts)).toEqual(\"^The value foo is not valid\");\n  });\n\n  it(\"uses the keys if the within value is an object\", function() {\n    expect(exclusion(\"foo\", {within: {foo: true}})).toBeDefined();\n    expect(exclusion(\"bar\", {within: {foo: true}})).not.toBeDefined();\n  });\n\n  it(\"uses the options as the within list if the options is an array\", function() {\n    expect(exclusion(\"foo\", [\"foo\", \"bar\"])).toBeDefined();\n    expect(exclusion(\"baz\", [\"foo\", \"bar\"])).not.toBeDefined();\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.exclusion.options = {\n      message: \"barfoo\",\n      within: [1, 2, 3]\n    };\n    var options = {message: 'foobar'};\n    expect(exclusion(2, options)).toEqual('foobar');\n    expect(exclusion(2, {})).toEqual('barfoo');\n    expect(validate.validators.exclusion.options).toEqual({\n      message: \"barfoo\",\n      within: [1, 2, 3]\n    });\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message, within: [\"foo\"]}\n      , value = \"foo\";\n    expect(exclusion(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/format-spec.js":"describe(\"validators.format\", function() {\n  var format = validate.validators.format.bind(validate.validators.format)\n    , options1 = {pattern: /^foobar$/i}\n    , options2 = {pattern: \"^foobar$\", flags: \"i\"};\n\n  afterEach(function() {\n    delete validate.validators.format.message;\n    delete validate.validators.format.options;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(format(null, options1)).not.toBeDefined();\n    expect(format(null, options2)).not.toBeDefined();\n    expect(format(undefined, options1)).not.toBeDefined();\n    expect(format(undefined, options2)).not.toBeDefined();\n  });\n\n  it(\"allows values that matches the pattern\", function() {\n    expect(format(\"fooBAR\", options1)).not.toBeDefined();\n    expect(format(\"fooBAR\", options2)).not.toBeDefined();\n  });\n\n  it(\"doesn't allow values that doesn't matches the pattern\", function() {\n    expect(format(\"\", options1)).toBeDefined(\"is invalid\");\n    expect(format(\"\", options2)).toBeDefined(\"is invalid\");\n    expect(format(\" \", options1)).toBeDefined(\"is invalid\");\n    expect(format(\" \", options2)).toBeDefined(\"is invalid\");\n    expect(format(\"barfoo\", options1)).toEqual(\"is invalid\");\n    expect(format(\"barfoo\", options2)).toEqual(\"is invalid\");\n  });\n\n  it(\"non strings are not allowed\", function() {\n    var obj = {toString: function() { return \"foobar\"; }};\n    expect(format(obj, options1)).toBeDefined();\n    expect(format(obj, options2)).toBeDefined();\n    expect(format(3, options1)).toBeDefined();\n    expect(format(3, options2)).toBeDefined();\n  });\n\n  it(\"non strings are not allowed\", function() {\n    expect(format(3, options1)).toBeDefined();\n    expect(format(3, options2)).toBeDefined();\n  });\n\n  it(\"doesn't allow partial matches\", function() {\n    var options1 = {pattern: /\\.png$/g}\n      , options2 = {pattern: \"\\\\.png$\", flags: \"g\"};\n    expect(format(\"foo.png\", options1)).toBeDefined();\n    expect(format(\"foo.png\", options2)).toBeDefined();\n  });\n\n  it(\"allows a custom message\", function() {\n    validate.validators.format.message = \"is using a default message\";\n\n    var options = {pattern: /^[a-z]+$/g};\n    expect(format(\"4711\", options)).toEqual(\"is using a default message\");\n\n    options.message = \"must only contain a-z\";\n    expect(format(\"4711\", options)).toEqual(\"must only contain a-z\");\n  });\n\n  it(\"supports the options being the pattern\", function() {\n    expect(format(\"barfoo\", options1.pattern)).toBeDefined();\n    expect(format(\"barfoo\", options2.pattern)).toBeDefined();\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.format.options = {\n      message: \"barfoo\",\n      pattern: \"abc\"\n    };\n    var options = {message: 'foobar'};\n    expect(format(\"cba\", options)).toEqual('foobar');\n    expect(format(\"cba\", {})).toEqual('barfoo');\n    expect(validate.validators.format.options).toEqual({\n      message: \"barfoo\",\n      pattern: \"abc\"\n    });\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message, pattern: /bar/}\n      , value = \"foo\";\n    expect(format(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/inclusion-spec.js":"describe(\"validators.inclusion\", function() {\n  var inclusion = validate.validators.inclusion.bind(validate.validators.inclusion)\n    , within = [\"foo\", \"bar\", \"baz\"];\n\n  afterEach(function() {\n    delete validate.validators.inclusion.message;\n    delete validate.validators.inclusion.message;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(inclusion(null, {})).not.toBeDefined();\n    expect(inclusion(undefined, {})).not.toBeDefined();\n  });\n\n  it(\"returns nothing if the value is allowed\", function() {\n    var opts = {within: within};\n    expect(inclusion(\"foo\", opts)).not.toBeDefined();\n    expect(inclusion(\"bar\", opts)).not.toBeDefined();\n    expect(inclusion(\"baz\", opts)).not.toBeDefined();\n  });\n\n  it(\"returns an error if the value is not included\", function() {\n    var opts = {within: within};\n    expect(inclusion(\"\", {})).toBeDefined();\n    expect(inclusion(\" \", {})).toBeDefined();\n    expect(inclusion(\"quux\", opts)).toEqual(\"^quux is not included in the list\");\n    expect(inclusion(false, opts)).toEqual(\"^false is not included in the list\");\n    expect(inclusion(1, opts)).toEqual(\"^1 is not included in the list\");\n  });\n\n  it(\"allows you to customize the message\", function() {\n    validate.validators.inclusion.message = \"^Default message: %{value}\";\n    var opts = {within: within};\n    expect(inclusion(\"quux\", opts)).toEqual(\"^Default message: quux\");\n\n    opts.message = \"^%{value} is not a valid choice\";\n    expect(inclusion(\"quux\", opts)).toEqual(\"^quux is not a valid choice\");\n  });\n\n  it(\"uses the keys if the within value is an object\", function() {\n    expect(inclusion(\"foo\", {within: {foo: true}})).not.toBeDefined();\n    expect(inclusion(\"bar\", {within: {foo: true}})).toBeDefined();\n  });\n\n  it(\"uses the options as the within list if the options is an array\", function() {\n    expect(inclusion(\"foo\", [\"foo\", \"bar\"])).not.toBeDefined();\n    expect(inclusion(\"baz\", [\"foo\", \"bar\"])).toBeDefined();\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.inclusion.options = {\n      message: \"barfoo\",\n      within: [1, 2, 3]\n    };\n    var options = {message: 'foobar'};\n    expect(inclusion(4, options)).toEqual('foobar');\n    expect(inclusion(4, {})).toEqual('barfoo');\n    expect(validate.validators.inclusion.options).toEqual({\n      message: \"barfoo\",\n      within: [1, 2, 3]\n    });\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message, within: [\"bar\"]}\n      , value = \"foo\";\n    expect(inclusion(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/length-spec.js":"describe('validator.length', function() {\n  var length = validate.validators.length.bind(validate.validators.length);\n\n  afterEach(function() {\n    delete validate.validators.length.notValid;\n    delete validate.validators.length.tooLong;\n    delete validate.validators.length.tooShort;\n    delete validate.validators.length.wrongLength;\n    delete validate.validators.length.options;\n  });\n\n  describe(\"is\", function() {\n    it(\"allows you to specify a fixed length the object has to be\", function() {\n      var value = {length: 10}\n        , options = {is: 10};\n      expect(length(value, options)).not.toBeDefined();\n\n      options.is = 11;\n      var expected = [\"is the wrong length (should be 11 characters)\"];\n      expect(length(value, options)).toEqual(expected);\n    });\n\n    it(\"allows a custom message\", function() {\n      var value = {length: 10}\n        , options = {is: 11};\n\n      validate.validators.length.wrongLength = \"default %{count}\";\n      expect(length(value, options)).toEqual([\"default 11\"]);\n\n      options.wrongLength = \"wrongLength %{count}\";\n      expect(length(value, options)).toEqual([\"wrongLength 11\"]);\n    });\n  });\n\n  describe(\"minimum\", function() {\n    it(\"allows you to specify a minimum value\", function() {\n      var value = {length: 10}\n        , options = {minimum: 10};\n      expect(length(value, options)).not.toBeDefined();\n\n      options.minimum = 11;\n      var expected = [\"is too short (minimum is 11 characters)\"];\n      expect(length(value, options)).toEqual(expected);\n    });\n\n    it(\"allows a custom message\", function() {\n      var value = {length: 10}\n        , options = {minimum: 11};\n\n      validate.validators.length.tooShort = \"default %{count}\";\n\n      expect(length(value, options)).toEqual([\"default 11\"]);\n\n      options.tooShort = \"tooShort %{count}\";\n      expect(length(value, options)).toEqual([\"tooShort 11\"]);\n    });\n  });\n\n  describe(\"maximum\", function() {\n    it(\"allows you to specify a maximum value\", function() {\n      var value = {length: 11}\n        , options = {maximum: 11};\n      expect(length(value, options)).not.toBeDefined();\n\n      options.maximum = 10;\n      var expected = [\"is too long (maximum is 10 characters)\"];\n      expect(length(value, options)).toEqual(expected);\n    });\n\n    it(\"allows a custom message\", function() {\n      var value = {length: 11}\n        , options = {maximum: 10};\n\n      validate.validators.length.tooLong = \"default %{count}\";\n      expect(length(value, options)).toEqual([\"default 10\"]);\n\n      options.tooLong = \"tooLong %{count}\";\n      expect(length(value, options)).toEqual([\"tooLong 10\"]);\n    });\n  });\n\n  it(\"allows empty values\", function() {\n    var options = {is: 10, minimum: 20, maximum: 5};\n    expect(length(null, options)).not.toBeDefined();\n    expect(length(undefined, options)).not.toBeDefined();\n  });\n\n  it(\"refuses values without a numeric length property\", function() {\n    spyOn(validate, \"error\");\n    var options = {is: 10, minimum: 10, maximum: 20};\n    expect(length(3.1415, options)).toBeDefined();\n    expect(length(-3.1415, options)).toBeDefined();\n    expect(length(0, options)).toBeDefined();\n    expect(length({foo: \"bar\"}, options)).toBeDefined();\n    expect(length({lengthi: 10}, options)).toBeDefined();\n    expect(length({length: \"foo\"}, options)).toBeDefined();\n    expect(length(3, {})).toBeDefined();\n    expect(validate.error).toHaveBeenCalled();\n  });\n\n  // This test is not a real life example, specifying is with anything else\n  // is just weird but hey.\n  it(\"allows you to specify is, minimum and maximum\", function() {\n    var options = {\n          is: 10,\n          minimum: 20,\n          maximum: 5\n      };\n      expect(length({length: 9}, options)).toHaveLength(3);\n      expect(length(\"foobar\", options)).toHaveLength(3);\n      expect(length(\"\", options)).toHaveLength(2);\n      expect(length(\" \", options)).toHaveLength(2);\n  });\n\n  it(\"return the message only once if specified\", function() {\n    var value = {length: 9}\n      , options = {\n          message: \"my message\",\n          is: 10,\n          minimum: 20,\n          maximum: 5\n        };\n      expect(length(value, options)).toBe(\"my message\");\n  });\n\n  it(\"doesn't override specific messages with the default one\", function() {\n    var value = {length: 3}\n      , options = {\n        is: 2,\n        minimum: 4,\n        maximum: 2,\n        wrongLength: \"wrongLength\",\n        tooLong: \"tooLong\",\n        tooShort: \"tooShort\"\n      };\n\n      validate.validators.length.notValid = \"default message\";\n      expect(length(value, options)).toHaveItems([\n        \"wrongLength\",\n        \"tooLong\",\n        \"tooShort\"\n      ]);\n  });\n\n  describe(\"tokenizer\", function() {\n    it(\"allows you to count words for example\", function() {\n      var options = {\n        maximum: 2,\n        tokenizer: function(value) { return value.split(/\\s+/g); }\n      };\n\n      expect(length(\"foo bar\", options)).not.toBeDefined();\n      expect(length(\"foo bar baz\", options)).toBeDefined();\n    });\n  });\n\n  it(\"supports default options\", function() {\n    var tokenizer = jasmine.createSpy(\"tokenizer\").and.returnValue({length: 3});\n    validate.validators.length.options = {\n      minimum: 10,\n      tokenizer: tokenizer,\n      message: \"barfoo\"\n    };\n    var options = {message: 'foobar'};\n    expect(length(4, options)).toEqual('foobar');\n    expect(length(4, {})).toEqual('barfoo');\n    expect(tokenizer).toHaveBeenCalled();\n    expect(validate.validators.length.options).toEqual({\n      minimum: 10,\n      tokenizer: tokenizer,\n      message: \"barfoo\"\n    });\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message, minimum: 10}\n      , value = \"foo\";\n    expect(length(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/numericality-spec.js":"describe(\"validators.numericality\", function() {\n  var numericality = validate.validators.numericality\n      .bind(validate.validators.numericality);\n\n  afterEach(function() {\n    var n = validate.validators.numericality;\n    delete n.message;\n    delete n.notValid;\n    delete n.notInteger;\n    delete n.notOdd;\n    delete n.notEven;\n    delete n.notGreaterThan;\n    delete n.notGreaterThanOrEqualTo;\n    delete n.notEqualTo;\n    delete n.notLessThan;\n    delete n.notLessThanOrEqualTo;\n    delete n.notDivisibleBy;\n    delete n.options;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(numericality(null, {})).not.toBeDefined();\n    expect(numericality(undefined, {})).not.toBeDefined();\n  });\n\n  it(\"allows numbers\", function() {\n    expect(numericality(3.14, {})).not.toBeDefined();\n    expect(numericality(\"3.14\", {})).not.toBeDefined();\n  });\n\n  it(\"doesn't allow non numbers\", function() {\n    var e = \"is not a number\";\n    expect(numericality(\"\", {})).toEqual(e);\n    expect(numericality(\"  \", {})).toEqual(e);\n    expect(numericality(\"foo\", {})).toEqual(e);\n    expect(numericality(NaN, {})).toEqual(e);\n    expect(numericality(false, {})).toEqual(e);\n    expect(numericality([1], {})).toEqual(e);\n    expect(numericality({foo: \"bar\"}, {})).toEqual(e);\n  });\n\n  it(\"doesn't allow strings if noStrings is true\", function() {\n    expect(numericality(\"3.14\", {noStrings: true})).toBeDefined();\n  });\n\n  it(\"uses the message if specified\", function() {\n    validate.validators.numericality.notValid = \"default message\";\n    expect(numericality(\"foo\", {})).toEqual(\"default message\");\n    expect(numericality(\"foo\", {message: \"my message\"})).toEqual(\"my message\");\n  });\n\n  it(\"uses the custom message if specified\", function() {\n    validate.validators.numericality.message = \"default generic message\";\n    expect(numericality(\"foo\", {})).toEqual(\"default generic message\");\n    var expected = \"default message\";\n    expect(numericality(\"foo\", {notValid: expected})).toEqual(\"default message\");\n    expect(numericality(\"foo\", {message: \"my message\"})).toEqual(\"my message\");\n  });\n\n  describe(\"onlyInteger\", function() {\n    it(\"allows integers\", function() {\n      expect(numericality(1, {onlyInteger: true})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow real numbers\", function() {\n      var expected = \"must be an integer\";\n      expect(numericality(3.14, {onlyInteger: true})).toEqual(expected);\n    });\n\n    it(\"uses the message if specified\", function() {\n      var opts = {onlyInteger: true};\n\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3.14, opts)).toEqual(\"default generic message\");\n\n      validate.validators.numericality.notInteger = \"default message\";\n      expect(numericality(3.14, opts)).toEqual(\"default message\");\n\n      opts.message = \"my message\";\n      expect(numericality(3.14, opts)).toEqual(\"my message\");\n    });\n\n    it(\"uses the custom message if specified\", function() {\n      var opts = {onlyInteger: true, notInteger: \"default message\" };\n      expect(numericality(3.14, opts)).toEqual(\"default message\");\n    });\n  });\n\n  describe(\"greaterThan\", function() {\n    it(\"allows numbers that are greater than\", function() {\n      expect(numericality(3.14, {greaterThan: 2.72})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow numbers that are smaller than or equal to\", function() {\n      var expected = [\"must be greater than 3.14\"];\n      expect(numericality(3.14, {greaterThan: 3.14})).toEqual(expected);\n      expect(numericality(2.72, {greaterThan: 3.14})).toEqual(expected);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(3.14, {greaterThan: 3.14, notGreaterThan: expected})).toEqual([expected]);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3.14, {greaterThan: 3.14})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notGreaterThan = \"default message\";\n      expect(numericality(3.14, {greaterThan: 3.14})).toEqual([\"default message\"]);\n    });\n  });\n\n  describe(\"greaterThanOrEqualTo\", function() {\n    it(\"allows numbers that are greater than or equal to\", function() {\n      expect(numericality(3.14, {greaterThanOrEqualTo: 2.72})).not.toBeDefined();\n      expect(numericality(2.72, {greaterThanOrEqualTo: 2.72})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow numbers that are smaller than\", function() {\n      var expected = [\"must be greater than or equal to 3.14\"];\n      expect(numericality(2.72, {greaterThanOrEqualTo: 3.14})).toEqual(expected);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(3.13, {greaterThanOrEqualTo: 3.14, notGreaterThanOrEqualTo: expected})).toEqual([expected]);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3.13, {greaterThanOrEqualTo: 3.14})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notGreaterThanOrEqualTo = \"default message\";\n      expect(numericality(3.13, {greaterThanOrEqualTo: 3.14})).toEqual([\"default message\"]);\n    });\n  });\n\n  describe(\"equalTo\", function() {\n    it(\"allows numbers that are equal to\", function() {\n      expect(numericality(2.72, {equalTo: 2.72})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow numbers that are not equal\", function() {\n      var expected = [\"must be equal to 2.72\"];\n      expect(numericality(3.14, {equalTo: 2.72})).toEqual(expected);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3.13, {equalTo: 3.14})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notEqualTo = \"default message\";\n      expect(numericality(3.13, {equalTo: 3.14})).toEqual([\"default message\"]);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(3.13, {equalTo: 3.14, notEqualTo:expected})).toEqual([expected]);\n    });\n  });\n\n  describe(\"lessThan\", function() {\n    it(\"allows numbers that are less than\", function() {\n      expect(numericality(2.72, {lessThan: 3.14})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow numbers that are greater than or equal to\", function() {\n      var expected = [\"must be less than 2.72\"];\n      expect(numericality(2.72, {lessThan: 2.72})).toEqual(expected);\n      expect(numericality(3.14, {lessThan: 2.72})).toEqual(expected);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3.14, {lessThan: 3.14})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notLessThan = \"default message\";\n      expect(numericality(3.14, {lessThan: 3.14})).toEqual([\"default message\"]);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(3.14, {lessThan: 3.14, notLessThan: expected})).toEqual([expected]);\n    });\n  });\n\n  describe(\"lessThanOrEqualTo\", function() {\n    it(\"allows numbers that are less than or equal to\", function() {\n      expect(numericality(2.72, {lessThanOrEqualTo: 3.14})).not.toBeDefined();\n      expect(numericality(3.14, {lessThanOrEqualTo: 3.14})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow numbers that are greater than\", function() {\n      var expected = [\"must be less than or equal to 2.72\"];\n      expect(numericality(3.14, {lessThanOrEqualTo: 2.72})).toEqual(expected);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3.15, {lessThanOrEqualTo: 3.14})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notLessThanOrEqualTo = \"default message\";\n      expect(numericality(3.15, {lessThanOrEqualTo: 3.14})).toEqual([\"default message\"]);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(3.15, {lessThanOrEqualTo: 3.14, notLessThanOrEqualTo: expected})).toEqual([expected]);\n    });\n  });\n\n  describe(\"divisibleBy\", function() {\n    it(\"allows numbers divisible by the value\", function() {\n      expect(numericality(0, {divisibleBy: 2})).not.toBeDefined();\n      expect(numericality(5, {divisibleBy: 5})).not.toBeDefined();\n      expect(numericality(16, {divisibleBy: 8})).not.toBeDefined();\n    });\n\n    it(\"doesn't allow numbers that are not divisible by the given number\", function() {\n      var expected = [\"must be divisible by 100\"];\n      expect(numericality(121, {divisibleBy: 100})).toEqual(expected);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(161, {divisibleBy: 200})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notDivisibleBy = \"default message\";\n      expect(numericality(161, {divisibleBy: 200})).toEqual([\"default message\"]);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(133, {divisibleBy: 4, notDivisibleBy: expected})).toEqual([expected]);\n    });\n  });\n\n  describe(\"odd\", function() {\n    it(\"allows odd numbers\", function() {\n      expect(numericality(1, {odd: true})).not.toBeDefined();\n      expect(numericality(3, {odd: true})).not.toBeDefined();\n      expect(numericality(5, {odd: true})).not.toBeDefined();\n    });\n\n    it(\"disallows even numbers\", function() {\n      var expected = [\"must be odd\"];\n      expect(numericality(0, {odd: true})).toEqual(expected);\n      expect(numericality(2, {odd: true})).toEqual(expected);\n      expect(numericality(4, {odd: true})).toEqual(expected);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(2, {odd: true})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notOdd = \"default message\";\n      expect(numericality(2, {odd: true})).toEqual([\"default message\"]);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(2, {odd: true, notOdd: expected})).toEqual([expected]);\n    });\n  });\n\n  describe(\"even\", function() {\n    it(\"allows even numbers\", function() {\n      expect(numericality(0, {even: true})).not.toBeDefined();\n      expect(numericality(2, {even: true})).not.toBeDefined();\n      expect(numericality(4, {even: true})).not.toBeDefined();\n    });\n\n    it(\"disallows odd numbers\", function() {\n      var expected = [\"must be even\"];\n      expect(numericality(1, {even: true})).toEqual(expected);\n      expect(numericality(3, {even: true})).toEqual(expected);\n      expect(numericality(5, {even: true})).toEqual(expected);\n    });\n\n    it(\"allows for a default message\", function() {\n      validate.validators.numericality.message = \"default generic message\";\n      expect(numericality(3, {even: true})).toEqual([\"default generic message\"]);\n\n      validate.validators.numericality.notEven = \"default message\";\n      expect(numericality(3, {even: true})).toEqual([\"default message\"]);\n    });\n\n    it(\"allows for a custom message\", function() {\n      var expected = \"custom message\";\n      expect(numericality(3, {even: true, notEven: expected})).toEqual([expected]);\n    });\n  });\n\n  it(\"can return multiple errors\", function() {\n    var options = {\n      greaterThan: 10,\n      greaterThanOrEqualTo: 10,\n      lessThan: 5,\n      lessThanOrEqualTo: 5,\n      divisibleBy: 10,\n      equalTo: 20,\n      odd: true,\n      even: true\n    };\n    expect(numericality(7.2, options)).toHaveLength(8);\n  });\n\n  it(\"returns options.message only once\", function() {\n    var options = {\n      greaterThan: 10,\n      greaterThanOrEqualTo: 10,\n      lessThan: 5,\n      lessThanOrEqualTo: 5,\n      divisibleBy: 10,\n      equalTo: 20,\n      odd: true,\n      even: true,\n      message: 'my message'\n    };\n    expect(numericality(7.2, options)).toEqual(\"my message\");\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.numericality.options = {\n      greaterThan: 10,\n      message: \"barfoo\"\n    };\n    var options = {message: 'foobar'};\n    expect(numericality(4, options)).toEqual('foobar');\n    expect(numericality(4, {})).toEqual('barfoo');\n    expect(validate.validators.numericality.options).toEqual({\n      greaterThan: 10,\n      message: \"barfoo\"\n    });\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message}\n      , value = \"foo\";\n    expect(numericality(value, options)).toBe(message);\n  });\n\n  describe(\"strict\", function() {\n    it(\"disallows prefixed zeros\", function() {\n      expect(numericality(\"01.0\", {strict: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\"0001.0000000\", {strict: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\"020\", {strict: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\"1.00\", {strict: true, onlyInteger: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\"1.\", {strict: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\"1.\", {strict: true, onlyInteger: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\".0\", {strict: true}))\n        .toEqual(\"must be a valid number\");\n      expect(numericality(\".1\", {strict: true}))\n        .toEqual(\"must be a valid number\");\n\n      expect(numericality(\"1.00\", {strict: true})).not.toBeDefined();\n      expect(numericality(\"1.0\", {strict: true})).not.toBeDefined();\n      expect(numericality(10, {strict: true})).not.toBeDefined();\n      expect(numericality(\"10\", {strict: true})).not.toBeDefined();\n      expect(numericality(\"0.1\", {strict: true})).not.toBeDefined();\n      expect(numericality(\"0\", {strict: true})).not.toBeDefined();\n    });\n  });\n\n  it(\"allows overriding the generic message\", function() {\n    validate.validators.numericality.message = \"default generic message\";\n    expect(numericality(\"foo\", {})).toEqual(\"default generic message\");\n\n    validate.validators.numericality.notValid = \"default not valid message\";\n    expect(numericality(\"foo\", {})).toEqual(\"default not valid message\");\n\n    expect(numericality(\"foo\", {notValid: \"not valid\"})).toEqual(\"not valid\");\n\n    expect(numericality(\"foo\", {message: \"some error\"})).toEqual(\"some error\");\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/presence-spec.js":"describe('validator.presence', function() {\n  var presence = validate.validators.presence.bind(validate.validators.presence);\n\n  afterEach(function() {\n    delete validate.validators.presence.message;\n    delete validate.validators.presence.options;\n  });\n\n  it(\"doesn't allow empty values\", function() {\n    expect(presence('', {})).toBeDefined();\n    expect(presence('  ', {})).toBeDefined();\n    expect(presence(null, {})).toBeDefined();\n    expect(presence(undefined, {})).toBeDefined();\n    expect(presence([], {})).toBeDefined();\n    expect(presence({}, {})).toBeDefined();\n  });\n\n  it(\"allows non empty values\", function() {\n    expect(presence('foo', {})).not.toBeDefined();\n    expect(presence(0, {})).not.toBeDefined();\n    expect(presence(false, {})).not.toBeDefined();\n    expect(presence([null], {})).not.toBeDefined();\n    expect(presence({foo: null}, {})).not.toBeDefined();\n    expect(presence(function(){return null;}, {})).not.toBeDefined();\n  });\n\n  it(\"has a nice default message\", function() {\n    var msg = presence(null, {});\n    expect(msg).toEqual(\"can't be blank\");\n  });\n\n  it(\"has an option for allowing empty values\", function() {\n    expect(presence('', {allowEmpty: true})).not.toBeDefined();\n    expect(presence('  ', {allowEmpty: true})).not.toBeDefined();\n    expect(presence([], {allowEmpty: true})).not.toBeDefined();\n    expect(presence({}, {allowEmpty: true})).not.toBeDefined();\n  });\n\n  it(\"also allows to specify your own nice message\", function() {\n    validate.validators.presence.message = \"default message\";\n    expect(presence(null, {})).toEqual(\"default message\");\n    expect(presence(null, {message: \"my message\"})).toEqual(\"my message\");\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.presence.options = {message: \"barfoo\"};\n    var options = {message: 'foobar'};\n    expect(presence(null, options)).toEqual('foobar');\n    expect(presence(null, {})).toEqual('barfoo');\n    expect(validate.validators.presence.options).toEqual({message: \"barfoo\"});\n    expect(options).toEqual({message: \"foobar\"});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message}\n      , value = null;\n    expect(presence(value, options)).toBe(message);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validate.js/node_modules/validate.js/specs/validators/url-spec.js":"describe(\"validators.url\", function() {\n  var url = validate.validators.url;\n  url = url.bind(url);\n\n  afterEach(function() {\n    delete validate.validators.url.message;\n    delete validate.validators.url.options;\n  });\n\n  it(\"allows empty values\", function() {\n    expect(url(null, {})).not.toBeDefined();\n    expect(url(undefined, {})).not.toBeDefined();\n  });\n\n  it(\"doesn't allow non strings\", function() {\n    expect(url(3.14, {})).toBeDefined();\n    expect(url(true, {})).toBeDefined();\n    expect(url({key: \"i'm a string\"}, {})).toBeDefined();\n  });\n\n  it(\"doesn't allow 'invalid' urls\", function() {\n    var expected = \"is not a valid url\";\n\n    expect(url(\"\", {})).toBeDefined();\n    expect(url(\" \", {})).toBeDefined();\n    expect(url(\"http://\", {})).toBeDefined();\n    expect(url(\"http://.\", {})).toBeDefined();\n    expect(url(\"http://..\", {})).toBeDefined();\n    expect(url(\"http://../\", {})).toBeDefined();\n    expect(url(\"http://?\", {})).toBeDefined();\n    expect(url(\"http://??\", {})).toBeDefined();\n    expect(url(\"http://??/\", {})).toBeDefined();\n    expect(url(\"http://#\", {})).toBeDefined();\n    expect(url(\"http://##\", {})).toBeDefined();\n    expect(url(\"http://##/\", {})).toBeDefined();\n    expect(url(\"http://foo.bar?q=Spaces should be encoded\", {})).toBeDefined();\n    expect(url(\"//\", {})).toBeDefined();\n    expect(url(\"//a\", {})).toBeDefined();\n    expect(url(\"///a\", {})).toBeDefined();\n    expect(url(\"///\", {})).toBeDefined();\n    expect(url(\"http:///a\", {})).toBeDefined();\n    expect(url(\"foo.com\", {})).toBeDefined();\n    expect(url(\"rdar://1234\", {})).toBeDefined();\n    expect(url(\"h://test\", {})).toBeDefined();\n    expect(url(\"http:// shouldfail.com\", {})).toBeDefined();\n    expect(url(\":// should fail\", {})).toBeDefined();\n    expect(url(\"http://foo.bar/foo(bar)baz quux\", {})).toBeDefined();\n    expect(url(\"ftps://foo.bar/\", {})).toBeDefined();\n    expect(url(\"http://-error-.invalid/\", {})).toBeDefined();\n    expect(url(\"http://-a.b.co\", {})).toBeDefined();\n    expect(url(\"http://a.b-.co\", {})).toBeDefined();\n    expect(url(\"http://0.0.0.0\", {})).toBeDefined();\n    expect(url(\"http://10.1.1.0\", {})).toBeDefined();\n    expect(url(\"http://10.1.1.255\", {})).toBeDefined();\n    expect(url(\"http://224.1.1.1\", {})).toBeDefined();\n    expect(url(\"http://1.1.1.1.1\", {})).toBeDefined();\n    expect(url(\"http://123.123.123\", {})).toBeDefined();\n    expect(url(\"http://3628126748\", {})).toBeDefined();\n    expect(url(\"http://.www.foo.bar/\", {})).toBeDefined();\n    expect(url(\"http://www.foo.bar./\", {})).toBeDefined();\n    expect(url(\"http://.www.foo.bar./\", {})).toBeDefined();\n    expect(url(\"http://10.1.1.1\", {})).toBeDefined();\n    expect(url(\"http://localhost\", {})).toBeDefined();\n  });\n\n  it(\"allows valid urls\", function() {\n    expect(url(\"http://foo.com\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/blah_blah\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/blah_blah/\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/blah_blah_(wikipedia)\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/blah_blah_(wikipedia)_(again)\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com?query=bar\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com#fragment=bar\", {})).not.toBeDefined();\n    expect(url(\"http://www.example.com/wpstyle/?p=364\", {})).not.toBeDefined();\n    expect(url(\"https://www.example.com/foo/?bar=baz&inga=42&quux\", {})).not.toBeDefined();\n    expect(url(\"https://www.example.com/foo/#bar=baz&inga=42&quux\", {})).not.toBeDefined();\n    expect(url(\"http://✪df.ws/123\", {})).not.toBeDefined();\n    expect(url(\"http://userid:password@example.com:8080\", {})).not.toBeDefined();\n    expect(url(\"http://userid:password@example.com:8080/\", {})).not.toBeDefined();\n    expect(url(\"http://userid@example.com\", {})).not.toBeDefined();\n    expect(url(\"http://userid@example.com/\", {})).not.toBeDefined();\n    expect(url(\"http://userid@example.com:8080\", {})).not.toBeDefined();\n    expect(url(\"http://userid@example.com:8080/\", {})).not.toBeDefined();\n    expect(url(\"http://userid:password@example.com\", {})).not.toBeDefined();\n    expect(url(\"http://userid:password@example.com/\", {})).not.toBeDefined();\n    expect(url(\"http://142.42.1.1/\", {})).not.toBeDefined();\n    expect(url(\"http://142.42.1.1:8080/\", {})).not.toBeDefined();\n    expect(url(\"http://➡.ws/䨹\", {})).not.toBeDefined();\n    expect(url(\"http://⌘.ws\", {})).not.toBeDefined();\n    expect(url(\"http://⌘.ws/\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/blah_(wikipedia)#cite-1\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/blah_(wikipedia)_blah#cite-1\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/unicode_(✪)_in_parens\", {})).not.toBeDefined();\n    expect(url(\"http://foo.com/(something)?after=parens\", {})).not.toBeDefined();\n    expect(url(\"http://☺.damowmow.com/\", {})).not.toBeDefined();\n    expect(url(\"http://code.google.com/events/#&product=browser\", {})).not.toBeDefined();\n    expect(url(\"http://j.mp\", {})).not.toBeDefined();\n    expect(url(\"http://foo.bar/?q=Test%20URL-encoded%20stuff\", {})).not.toBeDefined();\n    expect(url(\"http://مثال.إختبار\", {})).not.toBeDefined();\n    expect(url(\"http://例子.测试\", {})).not.toBeDefined();\n    expect(url(\"http://उदाहरण.परीक्षा\", {})).not.toBeDefined();\n    expect(url(\"http://-.~_!$&'()*+,;=:%40:80%2f::::::@example.com\", {})).not.toBeDefined();\n    expect(url(\"http://1337.net\", {})).not.toBeDefined();\n    expect(url(\"http://a.b-c.de\", {})).not.toBeDefined();\n    expect(url(\"http://223.255.255.254\", {})).not.toBeDefined();\n    expect(url(\"http://a.b--c.de/\", {})).not.toBeDefined();\n  });\n\n  it(\"allows local url and private networks if option is set\", function() {\n    expect(url(\"http://10.1.1.1\", {allowLocal: true})).not.toBeDefined();\n    expect(url(\"http://172.16.1.123\", {allowLocal: true})).not.toBeDefined();\n    expect(url(\"http://192.168.1.123\", {allowLocal: true})).not.toBeDefined();\n    expect(url(\"http://localhost/foo\", {allowLocal: true})).not.toBeDefined();\n    expect(url(\"http://localhost:4711/foo\", {allowLocal: true})).not.toBeDefined();\n    // Issue #95\n    expect(url(\"http://servername01:8153/go/cctray.xml\", {allowLocal: true})).not.toBeDefined();\n    expect(url(\"http://nicklas:password@localhost:4711/foo\", {allowLocal: true})).not.toBeDefined();\n  });\n\n  it(\"allows custom schemes option is set\", function() {\n    var options = {schemes: ['ftp', 'jdbc']};\n    expect(url(\"ftp://foo.bar.com\", options)).not.toBeDefined();\n    expect(url(\"jdbc://foo.bar.com\", options)).not.toBeDefined();\n    expect(url(\"http://foo.bar.com\", options)).toBeDefined();\n  });\n\n  it(\"allows you to customize the error message\", function() {\n    validate.validators.url.message = \"is totally not an url\";\n    expect(url(\"foobar\", {})).toEqual(\"is totally not an url\");\n\n    var options = { message: \"is not an url dude\" };\n    expect(url(\"foobar\", options)).toEqual(\"is not an url dude\");\n  });\n\n  it(\"supports default options\", function() {\n    validate.validators.url.options = {message: \"barfoo\", allowLocal: true, schemes: ['myscheme']};\n    var options = {message: 'foobar', allowLocal: true, schemes: ['myscheme']};\n    expect(url(\"foo\", options)).toEqual('foobar');\n    expect(url(\"foo\", {})).toEqual('barfoo');\n    expect(validate.validators.url.options).toEqual({message: \"barfoo\", allowLocal: true, schemes: ['myscheme']});\n    expect(options).toEqual({message: \"foobar\", allowLocal: true, schemes: ['myscheme']});\n  });\n\n  it(\"allows functions as messages\", function() {\n    var message = function() { return \"foo\"; };\n    var options = {message: message}\n      , value = \"foo\";\n    expect(url(value, options)).toBe(message);\n  });\n});\n"}